<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Notes - Polygon Miden Documentation</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/overview.html"><strong aria-hidden="true">1.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../introduction/getting-started.html"><strong aria-hidden="true">1.2.</strong> Getting started</a></li></ol></li><li class="chapter-item expanded "><a href="../architecture.html"><strong aria-hidden="true">2.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../architecture/accounts.html"><strong aria-hidden="true">2.1.</strong> Accounts</a></li><li class="chapter-item expanded "><a href="../architecture/notes.html" class="active"><strong aria-hidden="true">2.2.</strong> Notes</a></li><li class="chapter-item expanded "><a href="../architecture/assets.html"><strong aria-hidden="true">2.3.</strong> Assets</a></li><li class="chapter-item expanded "><a href="../architecture/transactions.html"><strong aria-hidden="true">2.4.</strong> Transactions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../transactions/transaction-execution.html"><strong aria-hidden="true">2.4.1.</strong> Transaction Execution</a></li><li class="chapter-item expanded "><a href="../transactions/transaction-kernel.html"><strong aria-hidden="true">2.4.2.</strong> Transaction Kernel</a></li><li class="chapter-item expanded "><a href="../transactions/transaction-procedures.html"><strong aria-hidden="true">2.4.3.</strong> Transaction Procedures</a></li><li class="chapter-item expanded "><a href="../transactions/transaction-modes.html"><strong aria-hidden="true">2.4.4.</strong> Transaction Modes</a></li></ol></li><li class="chapter-item expanded "><a href="../architecture/state.html"><strong aria-hidden="true">2.5.</strong> State</a></li><li class="chapter-item expanded "><a href="../architecture/execution.html"><strong aria-hidden="true">2.6.</strong> Execution</a></li></ol></li><li class="chapter-item expanded "><a href="../network.html"><strong aria-hidden="true">3.</strong> Network</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../network/miden-clients.html"><strong aria-hidden="true">3.1.</strong> Miden Clients</a></li><li class="chapter-item expanded "><a href="../network/miden-node.html"><strong aria-hidden="true">3.2.</strong> Miden Node</a></li><li class="chapter-item expanded "><a href="../network/verifier-contract.html"><strong aria-hidden="true">3.3.</strong> Verifier Contract</a></li><li class="chapter-item expanded "><a href="../network/bridge.html"><strong aria-hidden="true">3.4.</strong> Bridge</a></li></ol></li><li class="chapter-item expanded "><a href="../roadmap.html"><strong aria-hidden="true">4.</strong> Roadmap</a></li><li class="chapter-item expanded "><a href="../crypto-primitives.html"><strong aria-hidden="true">5.</strong> Cryptographic primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../crypto-primitives/tsmt.html"><strong aria-hidden="true">5.1.</strong> Tiered Sparse Merkle Tree (TSMT)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Polygon Miden Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xPolygonMiden/miden-base/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="notes"><a class="header" href="#notes">Notes</a></h1>
<p>Miden aims to achieve parallel transaction execution and privacy. The UTXO-model combined with client-side proofs provide those features. That means, in Miden exist notes as a way of transferring assets between and to interact with accounts. Notes can be consumed and produced asynchronously and privately. The concept of notes is a key difference between Ethereum’s Account-based model and Polygon Miden, which uses a hybrid UTXO- and Account-based <a href="state.html">state-model</a>. </p>
<h1 id="note-design"><a class="header" href="#note-design">Note design</a></h1>
<p>In Polygon Miden, accounts communicate with one another by producing and consuming notes. A note stores assets and a script that defines how this note can be consumed. </p>
<p>The diagram below illustrates the contents of a note:</p>
<p align="center">
    <img src="../diagrams/architecture/note/Note.png" style="width: 50%;">
</p>
<p>As shown in the above picture:</p>
<ul>
<li><strong>Assets →</strong> serves as <a href="assets.html">asset</a> container for a note. It can contain up to <code>256</code> assets stored in an array which can be reduced to a single hash.</li>
<li><strong>Script →</strong> will be executed in the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/transactions.html">transaction</a> in which the note is consumed. The script defines the conditions for the consumption, if the script fails, the note cannot be consumed.</li>
<li><strong>Inputs →</strong> used for the note script execution. They are placed onto the stack as parameters before a note's script gets executed. They must be defined at note creation. </li>
<li><strong>Serial number →</strong> a note's unique identifier to break linkability between <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-hash">note hash</a> and <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-nullifier">nullifier</a>. Should be a random <code>Word</code> chosen by the user - if revealed, the nullifier might be computed easily.</li>
</ul>
<p>In addition, a note has <strong>metadata</strong> including the sender and the note tag.</p>
<h1 id="notes-lifecycle"><a class="header" href="#notes-lifecycle">Note's lifecycle</a></h1>
<p>New notes are created by executing transactions. After verifying the transaction proof the operator adds either only the note hash (private notes) or the full note data (public notes) to the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/state.html#notes-database">Note DB</a>. Notes can be produced and consumed locally by users in local transactions or by the operator in a network transaction. Note consumption requires the transacting party to know the note data to compute the nullifier. After successful verification, the operator sets the corresponding entry in the Nullifier DB to <code>1</code> (=consumed). </p>
<p align="center">
    <img src="../diagrams/architecture/note/Note_life_cycle.png">
</p>
<p>The following sections will explain, how notes are created, stored, discovered and consumed. </p>
<h2 id="note-creation"><a class="header" href="#note-creation">Note creation</a></h2>
<p>Notes are created as outputs (<code>OutputNotes</code>) of Miden transactions. Operators record those notes to the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/state.html#note-database">Note DB</a>, after successful verification of the underlying transactions those notes can be consumed. </p>
<h2 id="the-note-script"><a class="header" href="#the-note-script">The note script</a></h2>
<p>Every note has a script which gets executed at note consumption. It is always executed in the context of a single account, and thus, may invoke zero or more of the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/accounts.html#code">account's functions</a>. The script allows for more than just the transferring of assets, they could be of arbitrary complexity thanks to the Turing completeness of the Miden VM</p>
<p>By design, every note script can be expressed as a unique hash or the root of a <a href="https://0xpolygonmiden.github.io/miden-vm/user_docs/assembly/main.html">Miden program MAST</a>. That also means every function is a commitment to the underlying code. That code cannot change unnoticed to the user because its hash would change. That way it is easy to recognize standardized notes and those which deviate.</p>
<p>There exist <a href="https://github.com/0xPolygonMiden/miden-base/tree/main/miden-lib/asm/note_scripts">standard note scripts</a> (P2ID, P2IDR, SWAP) that users can create and add to their notes using the <a href="../network/miden-clients.html">Miden client</a> or by calling internal <a href="https://github.com/0xPolygonMiden/miden-base/blob/fa63b26d845f910d12bd5744f34a6e55c08d5cde/miden-lib/src/notes/mod.rs#L15-L66">Rust code</a>.</p>
<h3 id="example-note-script-pay-to-id-p2id"><a class="header" href="#example-note-script-pay-to-id-p2id">Example note script Pay to ID (P2ID)</a></h3>
<details>
  <summary>Want to know more how to ensure a note can only be consumed by a specified account?</summary>
<h3 id="goal-of-the-p2id-script"><a class="header" href="#goal-of-the-p2id-script">Goal of the P2ID script</a></h3>
<p>The P2ID script defines a specific target account ID as the only account that can consume the note. Such notes ensure a targeted asset transfer. </p>
<h3 id="imports-and-context"><a class="header" href="#imports-and-context">Imports and context</a></h3>
<p>The P2ID script uses procedures from the account, note and wallet API.</p>
<pre><code>use.miden::account
use.miden::note
use.miden::contracts::wallets::basic-&gt;wallet
</code></pre>
<p>As discussed in detail in <a href="../transactions/transaction-procedures.html">transaction kernel procedures</a> certain procedures can only be invoked in certain contexts. The note script is being executed in the note context of the <a href="../transactions/transaction-kernel.html">transaction kernel</a>.</p>
<h3 id="main-script"><a class="header" href="#main-script">Main script</a></h3>
<p>The main part of the P2ID script checks if the executing account is the same as the account defined in the <code>NoteInputs</code>. The creator of the note defines the note script and the note inputs separately to ensure usage of the same standardized P2ID script regardless of the target account ID. That way, it is enough to check the script root (see above).</p>
<pre><code># Pay-to-ID script: adds all assets from the note to the account, assuming ID of the account
# matches target account ID specified by the note inputs.
#
# Requires that the account exposes: miden::contracts::wallets::basic::receive_asset procedure.
#
# Inputs: [SCRIPT_ROOT]
# Outputs: []
#
# Note inputs are assumed to be as follows:
# - target_account_id is the ID of the account for which the note is intended.
#
# FAILS if:
# - Account does not expose miden::contracts::wallets::basic::receive_asset procedure.
# - Account ID of executing account is not equal to the Account ID specified via note inputs.
# - The same non-fungible asset already exists in the account.
# - Adding a fungible asset would result in amount overflow, i.e., the total amount would be
#   greater than 2^63.
begin
    # drop the transaction script root
    dropw
    # =&gt; []
    
    # load the note inputs to memory starting at address 0
    push.0 exec.note::get_inputs
      # =&gt; [inputs_ptr]

    # read the target account id from the note inputs
    mem_load
    # =&gt; [target_account_id]

    exec.account::get_id
    # =&gt; [account_id, target_account_id, ...]

    # ensure account_id = target_account_id, fails otherwise
    assert_eq
    # =&gt; [...]

    exec.add_note_assets_to_account
    # =&gt; [...]
end
</code></pre>
<p>Every note script starts with the note script root on top of the stack. After the <code>dropw</code>, the stack is cleared. Next, the script loads the note inputs by first getting the pointer to the memory address of the inputs <code>exec.note::get_inputs</code>. The <code>push.0</code> just ensures that the pointer overrides the newly inserted <code>0</code>. Then, <code>mem_load</code> loads a <code>Felt</code> from the specified memory address and puts it on top of the stack, in that cases the   <code>target_account_id</code> defined by the creator of the note. Now, the note invokes <code>get_id</code> from the account API using <code>exec.account::get_id</code> - which is   possible even in the note context. Because, there are two account IDs on top of the stack now, <code>assert_eq</code> fails if the two account IDs (target_account_id and executing_account_id) are not the same. That means, the script cannot be successfully executed if executed by any other account than the account specified by the note creator using the note inputs.</p>
<p>If execution hasn't failed, the script invokes a helper procedure <code>exec.add_note_assets_to_account</code> to add the note's assets into the executing account's vault.</p>
<h3 id="add-assets"><a class="header" href="#add-assets">Add assets</a></h3>
<p>This procedure adds the assets held by the note into the account's vault. </p>
<pre><code>#! Helper procedure to add all assets of a note to an account.
#!
#! Inputs: []
#! Outputs: []
#!
proc.add_note_assets_to_account
    push.0 exec.note::get_assets
    # =&gt; [num_of_assets, 0 = ptr, ...]

    # compute the pointer at which we should stop iterating
    dup.1 add
    # =&gt; [end_ptr, ptr, ...]

    # pad the stack and move the pointer to the top
    padw movup.5
    # =&gt; [ptr, 0, 0, 0, 0, end_ptr, ...]

    # compute the loop latch
    dup dup.6 neq
    # =&gt; [latch, ptr, 0, 0, 0, 0, end_ptr, ...]

    while.true
        # =&gt; [ptr, 0, 0, 0, 0, end_ptr, ...]

        # save the pointer so that we can use it later
        dup movdn.5
        # =&gt; [ptr, 0, 0, 0, 0, ptr, end_ptr, ...]

        # load the asset and add it to the account
        mem_loadw call.wallet::receive_asset
        # =&gt; [ASSET, ptr, end_ptr, ...]

        # increment the pointer and compare it to the end_ptr
        movup.4 add.1 dup dup.6 neq
        # =&gt; [latch, ptr+1, ASSET, end_ptr, ...]
    end

    # clear the stack
    drop dropw drop
end
</code></pre>
<p>The procedure starts by calling <code>exec.note::get_assets</code> and putting the note's number of assets and the memory pointer of the first asset on top of the stack. Assets are stored in consecutive memory slots, so <code>dup.1 add</code> provides the last memory slot. Because <a href="assets.html">assets</a> are represented by <code>Words</code> in Miden Assembly, the procedure pads the stack with four <code>0</code>s. Now, if there is at least one asset (checked by <code>dup dup.6 neq</code>), the loop starts. It first saves the pointer for later use (<code>dup movdn.5</code>), then loads the first asset <code>mem_loadw</code> on top of the stack. Now, the procedure calls the a function of the account interface <code>call.wallet::receive_asset</code> to put the asset into the account's vault. The note script cannot directly call an account function to add the asset. The account must expose this function in its interface. Lastly, the pointer gets incremented, and if there is a second asset, the loop continues (<code>movup.4 add.1 dup dup.6 neq</code>). Finally, when all assets were put into the account's vault, the stack is cleared (<code>drop dropw drop</code>).</p>
</details>
<h2 id="note-storage-mode"><a class="header" href="#note-storage-mode">Note storage mode</a></h2>
<p>Similar to accounts, there are two storage modes for notes in Miden. Notes can be stored publicly in the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/state.html#notes-database">Note DB</a> with all data publicly visible for everyone. Alternatively, notes can be stored privately by committing only the note hash to the Note DB. </p>
<p>Every note has a unique note hash. It is defined as follows <code>hash(hash(hash(hash(serial_num, [0; 4]), script_hash), input_hash), vault_hash)</code>. The note hash can be computed if all the note data is known. </p>
<p><em>Info: To compute a note's hash, we do not need to know the note's <code>serial_num</code>. Knowing the hash of the <code>serial_num</code> (as well as <code>script_hash</code>, <code>input_hash</code> and <code>note_vault</code>) is also sufficient. We compute the hash of <code>serial_num</code> as <code>hash(serial_num, [0; 4])</code> to simplify processing within the VM.</em></p>
<p>Privately stored notes can only be consumed if the note data is known to the consumer. The note data must be provided as input to the <a href="../transactions/transaction-kernel.html">transaction kernel</a>. That means, there must be some off-chain communication to transmit the note's data from the sender to the target.</p>
<h2 id="note-discovery"><a class="header" href="#note-discovery">Note discovery</a></h2>
<p>Note discovery describes the process of Miden clients finding notes they want to consume. There are two ways to receive new relevant notes - getting notes via an off-chain channel or querying the Miden operator to request newly recorded relevant notes. 
The latter is done via note tags. Tags are part of the note's metadata and are represented by a <code>Felt</code>. The <code>SyncState</code> API of the <a href="../network/miden-node.html">Miden node</a> requires the Miden client to provide a <code>note_tag</code> value which is used as a filter in the operator's response. Tags are useful for note discovery enabling an easy collection of all notes matching a certain tag.</p>
<h2 id="note-consumption"><a class="header" href="#note-consumption">Note consumption</a></h2>
<p>As with creation, notes can only be consumed in Miden transactions. If a valid transaction consuming an <code>InputNote</code> gets verified by the Miden node, the note's unique nullifier gets added to the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/state.html#nullifier-database">Nullifier DB</a> and is therefore consumed. </p>
<h3 id="note-recipient-to-restrict-note-consumption"><a class="header" href="#note-recipient-to-restrict-note-consumption">Note recipient to restrict note consumption</a></h3>
<p>There are several ways to restrict the set of accounts that can consume a specific note. One way is to specifically define the target account ID as done in the P2ID and P2IDR note scripts. Another way is by using the concept of a <code>RECIPIENT</code>. Miden defines a <code>RECIPIENT</code> as: <code>hash(hash(hash(serial_num, [0; 4]), script_hash), input_hash)</code> represented as <code>Word</code>. This concept restricts note consumption to those users who know the pre-image data of <code>RECIPIENT</code> - which might be a bigger set than a single account.</p>
<p>During the <a href="../transactions/transaction-kernel.html">transaction prologue</a> the users needs to provide all the data to compute the note hash. That means, one can create notes that can only be consumed if the <code>serial_num</code> and other data is known. This information can be passed on off-chain by the sender to the consumer. This is only useful with private notes.For public notes, all note data is known, and anyone can compute the <code>RECIPIENT</code>. </p>
<p>You can see in the standard <a href="https://github.com/0xPolygonMiden/miden-base/blob/main/miden-lib/asm/note_scripts/SWAP.masm">SWAP note script</a> how <code>RECIPIENT</code> is used. Here, using a single hash, is sufficient to ensure that the swapped asset and its note can only be consumed by the defined target.</p>
<h3 id="note-nullifier-to-ensure-private-consumption"><a class="header" href="#note-nullifier-to-ensure-private-consumption">Note nullifier to ensure private consumption</a></h3>
<p>The note's nullifier is computed as <code>hash(serial_num, script_hash, input_hash, vault_hash)</code>.</p>
<p>This achieves the following properties:</p>
<ul>
<li>Every note can be reduced to a single unique nullifier.</li>
<li>One cannot derive a note's hash from its nullifier.</li>
<li>To compute the nullifier, one must know all components of the note: <code>serial_num</code>, <code>script_hash</code>, <code>input_hash</code>, and <code>vault_hash</code>.</li>
</ul>
<p>That means if a note is private and the operator stores only the note's hash, only those with the note details know if this note has been consumed already. Zcash first <a href="https://zcash.github.io/orchard/design/nullifiers.html#nullifiers">introduced</a> this approach.</p>
<p align="center">
    <img src="../diagrams/architecture/note/Nullifier.png">
</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../architecture/accounts.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../architecture/assets.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../architecture/accounts.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../architecture/assets.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
