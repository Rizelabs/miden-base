<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Accounts - Polygon Miden Documentation</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/overview.html"><strong aria-hidden="true">1.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../introduction/getting-started.html"><strong aria-hidden="true">1.2.</strong> Getting started</a></li></ol></li><li class="chapter-item expanded "><a href="../architecture.html"><strong aria-hidden="true">2.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../architecture/accounts.html" class="active"><strong aria-hidden="true">2.1.</strong> Accounts</a></li><li class="chapter-item expanded "><a href="../architecture/notes.html"><strong aria-hidden="true">2.2.</strong> Notes</a></li><li class="chapter-item expanded "><a href="../architecture/assets.html"><strong aria-hidden="true">2.3.</strong> Assets</a></li><li class="chapter-item expanded "><a href="../architecture/transactions.html"><strong aria-hidden="true">2.4.</strong> Transactions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../transactions/transaction-execution.html"><strong aria-hidden="true">2.4.1.</strong> Transaction Execution</a></li><li class="chapter-item expanded "><a href="../transactions/transaction-kernel.html"><strong aria-hidden="true">2.4.2.</strong> Transaction Kernel</a></li><li class="chapter-item expanded "><a href="../transactions/transaction-procedures.html"><strong aria-hidden="true">2.4.3.</strong> Transaction Procedures</a></li><li class="chapter-item expanded "><a href="../transactions/transaction-modes.html"><strong aria-hidden="true">2.4.4.</strong> Transaction Modes</a></li></ol></li><li class="chapter-item expanded "><a href="../architecture/state.html"><strong aria-hidden="true">2.5.</strong> State</a></li><li class="chapter-item expanded "><a href="../architecture/execution.html"><strong aria-hidden="true">2.6.</strong> Execution</a></li></ol></li><li class="chapter-item expanded "><a href="../network.html"><strong aria-hidden="true">3.</strong> Network</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../network/miden-clients.html"><strong aria-hidden="true">3.1.</strong> Miden Clients</a></li><li class="chapter-item expanded "><a href="../network/miden-node.html"><strong aria-hidden="true">3.2.</strong> Miden Node</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../miden-node/miden-node-rpc.html"><strong aria-hidden="true">3.2.1.</strong> Miden node RPC</a></li><li class="chapter-item expanded "><a href="../miden-node/miden-node-store.html"><strong aria-hidden="true">3.2.2.</strong> Miden node store</a></li><li class="chapter-item expanded "><a href="../miden-node/miden-node-block-producer.html"><strong aria-hidden="true">3.2.3.</strong> Miden node block producer</a></li></ol></li><li class="chapter-item expanded "><a href="../network/verifier-contract.html"><strong aria-hidden="true">3.3.</strong> Verifier Contract</a></li><li class="chapter-item expanded "><a href="../network/bridge.html"><strong aria-hidden="true">3.4.</strong> Bridge</a></li></ol></li><li class="chapter-item expanded "><a href="../roadmap.html"><strong aria-hidden="true">4.</strong> Roadmap</a></li><li class="chapter-item expanded "><a href="../crypto-primitives.html"><strong aria-hidden="true">5.</strong> Cryptographic primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../crypto-primitives/tsmt.html"><strong aria-hidden="true">5.1.</strong> Tiered Sparse Merkle Tree (TSMT)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Polygon Miden Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xPolygonMiden/miden-base/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="accounts"><a class="header" href="#accounts">Accounts</a></h1>
<p>Miden aims to support expressive smart contracts via a Turing-complete language. For smart contracts the go-to solution is account-based state. In Miden, an account is an entity which holds assets and defines rules of how these assets can be transferred. They are basic building blocks representing a user or an autonomous smart contract.</p>
<h2 id="account-design"><a class="header" href="#account-design">Account Design</a></h2>
<p>The diagram below illustrates basic components of an account. In Miden every account is a smart contract.</p>
<p align="center">
    <img src="../diagrams/architecture/account/Account_Definition.png" style="width: 25%;">
</p>
<p>In the above picture, you can see:</p>
<ul>
<li><strong>Account ID →</strong> a unique identifier of an account which does not change throughout its lifetime</li>
<li><strong>Storage →</strong> user-defined data which can be stored in an account</li>
<li><strong>Nonce →</strong> a counter which must be incremented whenever the account state changes</li>
<li><strong>Vault →</strong> a collection of assets stored in an account</li>
<li><strong>Code →</strong> a collection of functions which define the external interface for an account</li>
</ul>
<h3 id="account-id"><a class="header" href="#account-id">Account ID</a></h3>
<p>~63 bits (1 field element) long identifier for the account. The four most significant bits specify its <a href="https://0xpolygonmiden.github.io/miden-base/architecture/accounts.html#account-types">account type</a> - regular, immutable, faucet - and the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/accounts.html#account-storage-modes">storage mode</a> - public or private. </p>
<h3 id="account-storage"><a class="header" href="#account-storage">Account Storage</a></h3>
<p>Storage for user-defined data. <code>AccountStorage</code> is composed of two components.</p>
<p>The first component is a simple sparse Merkle tree of depth <code>8</code> which is index addressable. This provides the user with <code>256</code> <code>Word</code> slots.</p>
<p>Users requiring additional storage can use the second component a <code>MerkleStore</code>. It allows users to store any Merkle structures they need. The root of the Merkle structure can be stored as a leaf in a simple sparse Merkle tree. When <code>AccountStorage</code> is serialized it will check if any of the leafs in the simple sparse Merkle tree are Merkle roots of other Merkle structures. If any Merkle roots are found then the Merkle structures will be persisted in the <code>AccountStorage</code> <code>MerkleStore</code>.</p>
<h3 id="nonce"><a class="header" href="#nonce">Nonce</a></h3>
<p>Counter which must be incremented whenever the account state changes. Nonce values must be strictly monotonically increasing and can be incremented by any value smaller than 2^{32} for every account update.</p>
<h3 id="vault"><a class="header" href="#vault">Vault</a></h3>
<p>Asset container for an account.</p>
<p>An account vault can contain an unlimited number of <a href="https://0xpolygonmiden.github.io/miden-base/architecture/assets.html">assets</a>. The assets are stored in a sparse
Merkle tree as follows:</p>
<ul>
<li>For fungible assets, the index of a node is defined by the issuing faucet ID, and the value
of the node is the asset itself. Thus, for any fungible asset there will be only one node
in the tree.</li>
<li>For non-fungible assets, the index is defined by the asset itself, and the asset is also
the value of the node.</li>
</ul>
<p>An account vault can be reduced to a single hash which is the root of the sparse Merkle tree.</p>
<h3 id="code"><a class="header" href="#code">Code</a></h3>
<p>Interface for accounts. In Miden every account is a smart contract. It has an interface that exposes functions that can be called by <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-scripts">note scripts</a> and <a href="https://0xpolygonmiden.github.io/miden-base/transactions/transaction-kernel.html#the-transaction-script-processing">transaction scripts</a>. Users cannot call those functions directly. </p>
<p>Functions exposed by the account have the following properties:</p>
<ul>
<li>Functions are actually roots of <a href="https://0xpolygonmiden.github.io/miden-vm/user_docs/assembly/main.html">Miden program MASTs</a> (i.e., a 32-byte hash). Thus, function identifier is a commitment to the code which is executed when a function is invoked.</li>
<li>Only account functions have mutable access to an account's storage and vault. Therefore, the only way to modify an account's internal state is through one of the account's functions.</li>
<li>Account functions can take parameters and can create new notes.</li>
</ul>
<p><em>Note: Since code in Miden is expressed as MAST, every function is a commitment to the underlying code. The code cannot change unnoticed to the user because its hash would change. Behind any MAST root there can only be <code>256</code> functions</em></p>
<h4 id="example-account-code"><a class="header" href="#example-account-code">Example Account Code</a></h4>
<p>Currently, Miden provides two standard implementations for account code. </p>
<h5 id="basic-user-account-regular-updatable-account"><a class="header" href="#basic-user-account-regular-updatable-account">Basic user account (Regular updatable account)</a></h5>
<p>There is a standard for a basic user account. It exposes three functions via its interface.</p>
<details>
  <summary>Want to see the code?</summary>
<pre><code>  use.miden::contracts::wallets::basic-&gt;basic_wallet
  use.miden::contracts::auth::basic

  export.basic_wallet::receive_asset
  export.basic_wallet::send_asset
  export.basic::auth_tx_rpo_falcon512
</code></pre>
</details>
<p><a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-scripts">Note scripts</a> or <a href="https://0xpolygonmiden.github.io/miden-base/transactions/transaction-kernel.html#the-transaction-script-processing">transaction scripts</a> can call <code>receive_asset</code> and <code>send_asset</code> and in doing so, the account can receive and send assets. Transaction scripts can also call <code>auth_tx_rpo_falcon512</code> and authenticate the transaction. It is important to know, that without correct authentication, i.e. knowing the correct private key, a note cannot successfully invoke receive and send asset.</p>
<h5 id="basic-fungible-faucet-faucet-for-fungible-assets"><a class="header" href="#basic-fungible-faucet-faucet-for-fungible-assets">Basic fungible faucet (Faucet for fungible assets)</a></h5>
<p>There is also a standard for a <a href="https://github.com/0xPolygonMiden/miden-base/blob/main/miden-lib/asm/miden/contracts/faucets/basic_fungible.masm">basic fungible faucet</a>.</p>
<details>
  <summary>Want to see the code?</summary>
<pre><code>#! Distributes freshly minted fungible assets to the provided recipient.
#!
#! ...
export.distribute
    # get max supply of this faucet. We assume it is stored at pos 3 of slot 1
    push.METADATA_SLOT exec.account::get_item drop drop drop
    # =&gt; [max_supply, amount, tag, RECIPIENT, ...]

    # get total issuance of this faucet so far and add amount to be minted
    exec.faucet::get_total_issuance
    # =&gt; [total_issuance, max_supply, amount, tag, RECIPIENT, ...]

    # compute maximum amount that can be minted, max_mint_amount = max_supply - total_issuance
    sub
    # =&gt; [max_supply - total_issuance, amount, tag, RECIPIENT, ...]

    # check that amount =&lt; max_supply - total_issuance, fails if otherwise
    dup.1 gte assert
    # =&gt; [asset, tag, RECIPIENT, ...]

    # creating the asset
    exec.asset::create_fungible_asset
    # =&gt; [ASSET, tag, RECIPIENT, ...]

    # mint the asset; this is needed to satisfy asset preservation logic.
    exec.faucet::mint
    # =&gt; [ASSET, tag, RECIPIENT, ...]

    # create a note containing the asset
    exec.tx::create_note
    # =&gt; [note_ptr, ZERO, ZERO, ...]
end

#! Burns fungible assets.
#!
#! ...
export.burn
    # burning the asset
    exec.faucet::burn
    # =&gt; [ASSET]

    # increments the nonce (anyone should be able to call that function)
    push.1 exec.account::incr_nonce

    # clear the stack
    padw swapw dropw
    # =&gt; [...]
end
</code></pre>
</details>
<p>The contract exposes two functions <code>distribute</code> and <code>burn</code>. The first function <code>distribute</code> can only be called by the faucet owner, otherwise it fails. As inputs, the function expects everything that is needed to create a note containing the freshly minted asset, i.e., amount, <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-metadata">tag</a>, <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-recipient">RECIPIENT</a>.</p>
<p>The second function <code>burn</code> can be called by anyone to burn the tokens that are contained in a note.</p>
<p><em>Info: The difference is that the <code>burn</code> procedure exposes <code>exec.account::incr_nonce</code>, so by calling <code>burn</code> the nonce of the executing account gets increased by 1 and the transaction will pass the epilogue check. The <code>distribute</code> procedure does not expose that. That means the executing user needs to call <code>basic::auth_tx_rpo_falcon512</code> which requires the private key.</em></p>
<h2 id="account-creation"><a class="header" href="#account-creation">Account creation</a></h2>
<p>For an account to exist it must be present in the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/state.html#account-database">Account DB</a> kept by the Miden node(s). However, new accounts can be created locally by users using a wallet.</p>
<p>The process is as follows:</p>
<ul>
<li>Alice grinds a new Account ID (according to the account types) using a wallet</li>
<li>Alice's Miden client requests the Miden node to check if new Account ID already exists</li>
<li>Alice shares the new Account ID to Bob (eg. when Alice wants to receive funds)</li>
<li>Bob executes a transaction and creates a note that contains an asset for Alice</li>
<li>Alice consumes Bob's note to receive the asset in a transaction</li>
<li>Depending on the account storage mode (private vs. public) and transaction type (local vs. network) the Operator receives the new Account ID eventually and - if the transaction is correct - adds the ID to the Account DB</li>
</ul>
<p>For a user to create an account we have 2 solutions at the moment:</p>
<ol>
<li>Use the <a href="https://github.com/0xPolygonMiden/miden-client/tree/main">Miden client</a> as a wallet</li>
<li>Use the Miden Base builtin functions for wallet creation: <a href="https://github.com/0xPolygonMiden/miden-base/blob/4e6909bbaf65e77d7fa0333e4664be81a2f65eda/miden-lib/src/accounts/wallets/mod.rs#L15">Basic wallet</a>, <a href="https://github.com/0xPolygonMiden/miden-base/blob/4e6909bbaf65e77d7fa0333e4664be81a2f65eda/miden-lib/src/accounts/faucets/mod.rs#L11">Fungible faucet</a></li>
</ol>
<h2 id="account-types"><a class="header" href="#account-types">Account types</a></h2>
<p>There are four types of accounts in Miden:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Regular updatable account</th><th>Regular immutable account</th><th>Faucet for fungible assets</th><th>Faucet for non-fungible assets</th></tr></thead><tbody>
<tr><td><strong>Description</strong></td><td>For most users, e.g. a wallet. Code changes allowed, including public API.</td><td>For most smart contracts. Once deployed code is immutable.</td><td>Users can issue fungible assets and customize them.</td><td>Users can issue non-fungible assets and customize them.</td></tr>
<tr><td><strong>Code updatability</strong></td><td>yes</td><td>no</td><td>no</td><td>no</td></tr>
<tr><td><strong>Most significant bits</strong></td><td><code>00</code></td><td><code>01</code></td><td><code>10</code></td><td><code>11</code></td></tr>
</tbody></table>
</div>
<h2 id="account-storage-modes"><a class="header" href="#account-storage-modes">Account storage modes</a></h2>
<p>Account data - stored by the Miden node - can be public, private, or encrypted. The third and fourth most significant bits of the account ID specifies whether the account data is public <code>00</code>, encrypted <code>01</code>, or private <code>11</code>.</p>
<ul>
<li>Accounts with <strong>public state</strong>, where the actual state is stored onchain. These would be similar to how accounts work in public blockchains. Smart contracts that depend on public shared state should be stored public on Miden, e.g., DEX contract.</li>
<li>Accounts with <strong>private state</strong>, where only the hash of the account is stored onchain. Users who want stay private and take care of their own data should choose this mode. The hash is defined as: <code>hash([account ID, 0, 0, nonce], [vault root], [storage root], [code root])</code>.</li>
</ul>
<p>In the future we will also support <strong>encrypted state</strong> which will be onchain but encrypted. * Depending on the account storage mode (private vs. encrypted vs. public) and transaction type (local vs. network) the operator receives the new Account ID eventually and - if the transaction is correct - adds the ID to the Account DB</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../architecture.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../architecture/notes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../architecture.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../architecture/notes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
