<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Polygon Miden Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/overview.html"><strong aria-hidden="true">1.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="introduction/getting-started.html"><strong aria-hidden="true">1.2.</strong> Getting started</a></li></ol></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">2.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/accounts.html"><strong aria-hidden="true">2.1.</strong> Accounts</a></li><li class="chapter-item expanded "><a href="architecture/notes.html"><strong aria-hidden="true">2.2.</strong> Notes</a></li><li class="chapter-item expanded "><a href="architecture/assets.html"><strong aria-hidden="true">2.3.</strong> Assets</a></li><li class="chapter-item expanded "><a href="architecture/transactions.html"><strong aria-hidden="true">2.4.</strong> Transactions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="transactions/transaction-execution.html"><strong aria-hidden="true">2.4.1.</strong> Transaction Execution</a></li><li class="chapter-item expanded "><a href="transactions/transaction-kernel.html"><strong aria-hidden="true">2.4.2.</strong> Transaction Kernel</a></li><li class="chapter-item expanded "><a href="transactions/transaction-procedures.html"><strong aria-hidden="true">2.4.3.</strong> Transaction Procedures</a></li><li class="chapter-item expanded "><a href="transactions/transaction-modes.html"><strong aria-hidden="true">2.4.4.</strong> Transaction Modes</a></li></ol></li><li class="chapter-item expanded "><a href="architecture/state.html"><strong aria-hidden="true">2.5.</strong> State</a></li><li class="chapter-item expanded "><a href="architecture/execution.html"><strong aria-hidden="true">2.6.</strong> Execution</a></li></ol></li><li class="chapter-item expanded "><a href="network.html"><strong aria-hidden="true">3.</strong> Network</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="network/miden-clients.html"><strong aria-hidden="true">3.1.</strong> Miden Clients</a></li><li class="chapter-item expanded "><a href="network/miden-node.html"><strong aria-hidden="true">3.2.</strong> Miden Node</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="miden-node/miden-node-rpc.html"><strong aria-hidden="true">3.2.1.</strong> Miden node RPC</a></li><li class="chapter-item expanded "><a href="miden-node/miden-node-store.html"><strong aria-hidden="true">3.2.2.</strong> Miden node store</a></li><li class="chapter-item expanded "><a href="miden-node/miden-node-block-producer.html"><strong aria-hidden="true">3.2.3.</strong> Miden node block producer</a></li></ol></li><li class="chapter-item expanded "><a href="network/verifier-contract.html"><strong aria-hidden="true">3.3.</strong> Verifier Contract</a></li><li class="chapter-item expanded "><a href="network/bridge.html"><strong aria-hidden="true">3.4.</strong> Bridge</a></li></ol></li><li class="chapter-item expanded "><a href="roadmap.html"><strong aria-hidden="true">4.</strong> Roadmap</a></li><li class="chapter-item expanded "><a href="crypto-primitives.html"><strong aria-hidden="true">5.</strong> Cryptographic primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crypto-primitives/tsmt.html"><strong aria-hidden="true">5.1.</strong> Tiered Sparse Merkle Tree (TSMT)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Polygon Miden Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xPolygonMiden/miden-base/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="polygon-miden"><a class="header" href="#polygon-miden">Polygon Miden</a></h1>
<p>Miden is a zero-knowledge rollup for high-throughput and private applications. Miden allows users to prove state changes of local data where the network only tracks a commitment of it. This leads to privacy and high-throughput. We think, Privacy Scales Better. Users can also let the Operator prove public state changes as in other known rollups.</p>
<p>Polygon Miden is a modular execution layer that extends Ethereum's capabilities using powerful features such as parallel transaction execution and client-side proving. With Miden, developers can create novel, high-throughput, privacy preserving dApps for DeFi, RWA and Autonomous Worlds using their favorite languages such as Rust and TypeScript.</p>
<p>If you want to join the technical discussion, please check out</p>
<ul>
<li>the <a href="https://discord.gg/0xpolygondevs">Discord</a></li>
<li>the <a href="https://github.com/0xPolygonMiden">Repo</a></li>
<li>the <a href="roadmap.html">Roadmap</a></li>
</ul>
<blockquote>
<p><em>This documentation is still Work In Progress. Some topics have been discussed in greater depth, while others require additional clarification. Sections of this documentation might later be reorganized in order to achieve a better flow.</em></p>
</blockquote>
<h2 id="status-and-features"><a class="header" href="#status-and-features">Status and features</a></h2>
<p>Polygon Miden is currently on release v0.1. This is an early version of the protocol and its components. We expect to keep making even breaking changes to all components. </p>
<p>At this point, adventurous Pioneers can execute first transactions and send assets to each other. Polygon Miden doesn't offer all the features one would expect from a zkRollup, yet. During 2024, we expect to offer gradually more features. Eventually, developers should be able to code any application they want on Polygon Miden.</p>
<h3 id="feature-highlights"><a class="header" href="#feature-highlights">Feature highlights</a></h3>
<ul>
<li><strong>Private accounts</strong>. The Miden Operator only tracks a commitment to any account data in the public database. Users can only execute smart contracts of which they know the interface. </li>
<li><strong>Private notes</strong>. Like private accounts, the Miden Operator only tracks a commitment to any notes in the public database. Users need to communicate note details to each other off-chain (via any side channel) in order to consume private notes in transactions.</li>
<li><strong>Local transaction execution</strong>. The Miden Client allows for local transaction execution and proving. The Miden Operator verifies the proof and if valid, the state DBs are updated with the new data.</li>
<li><strong>Simple smart contracts</strong>. Currently, there are three different smart contracts available. A basic wallet smart contracts to send and receive assets, and fungible and non-fungible faucets to mint and burn assets. All accounts are written in MASM.</li>
<li><strong>P2ID, P2IDR and SWAP note scripts</strong>. Currently, there are three different note scripts available. Two different versions of pay-to-id scripts of which P2IDR is reclaimable, and a swap script that allows for simple token swaps.</li>
<li><strong>Simple block building</strong>. The Miden Operator running the Miden Node is able to build blocks containing transactions. There is no recursive verification of transactions enabled yet.</li>
<li><strong>Maintaining state</strong>. The Miden Node stores all necessary information already in its State DBs and provides this infos via its RPC endpoint.</li>
</ul>
<h3 id="planned-features"><a class="header" href="#planned-features">Planned features</a></h3>
<ul>
<li><strong>Public accounts</strong>. Polygon Miden will support public smart contracts as know on Ethereum. Code and state of those accounts will be visible to the network and anyone can execute transactions against them.</li>
<li><strong>Public notes</strong>. As with public accounts, also public notes will be supported. That means, note data will be publicly stored by the Miden Operator. Note consumption will not be private. </li>
<li><strong>Customized smart contracts</strong>. Accounts can expose any interface in the future. This is the Miden version of a smart contract. Account code can be arbitrary complex due to the underlying Turing-complete Miden VM.</li>
<li><strong>Customized note scripts</strong>. Users will be able to write their own note scripts using the Miden Client. Note scripts are executed during note consumption and they can be arbitrary complex due to the underlying Turing-complete Miden VM.</li>
<li><strong>Network transactions</strong>. Transaction execution and proving can be outsourced to the network and to the Miden Operator. Those transactions will be necessary when it comes to public shared state, and they can be useful if the user's device is not powerful enough to prove transactions efficiently.</li>
<li><strong>Rust compiler</strong>. In order to write account code, note or transaction scripts, in Rust, there will be a Rust -&gt; Miden Assembly compiler. </li>
<li><strong>Block and epoch proofs</strong>. The Miden Node will recursively verify transactions and in doing so build batches of transactions, blocks and epochs. </li>
</ul>
<h2 id="benefits-of-polygon-miden"><a class="header" href="#benefits-of-polygon-miden">Benefits of Polygon Miden</a></h2>
<ul>
<li>Ethereum security</li>
<li>Developers can build applications infeasible on other systems, e.g.
<ul>
<li><strong>onchain order book exchange</strong> due to parallel tx execution and updatable transactions</li>
<li><strong>complex, incomplete information games</strong> due to client-side proving and cheap complex computations</li>
<li><strong>safe wallets</strong> due to assets being stored in the accounts and account state can be hidden</li>
</ul>
</li>
<li>Better privacy properties than on Ethereum - first web2 privacy, later even stronger privacy guarantees</li>
<li>Transactions can be recalled and updated</li>
<li>Lower fees due to client-side proving</li>
<li>dApps on Miden are safe to use due to account abstraction and compile-time safe Rust smart contracts</li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Licensed under the <a href="http://opensource.org/licenses/MIT">MIT license</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>This documentation presents detailed guides on:</p>
<ul>
<li><a href="introduction/getting-started.html">Getting started</a></li>
<li><a href="introduction/../architecture.html">Architecture</a></li>
<li><a href="introduction/../network.html">Network design</a></li>
<li><a href="introduction/../roadmap.html">Roadmap</a></li>
<li><a href="introduction/../crypto-primitives.html">Cryptographic primitives</a></li>
</ul>
<p><strong>Getting started</strong> provides an hands-om guide on how builders can use our <strong>testnet</strong>.</p>
<p><strong>Architecture</strong> describes Miden's unique state and execution model - an actor-based model with concurrent off-chain state.</p>
<p><strong>Network design</strong> describes how the architecture is implemented into a zero-knowledge rollup. It describes the software components, RPC interfaces of the Miden Nodes and Cliets.</p>
<p><strong>Roadmap</strong> shows the timeline for user facing features that users can expect.</p>
<p><strong>Cryptographic primitives</strong> provides an in-depth description of the primitives used in the Miden rollup and the Miden VM.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<blockquote>
<p>[WIP]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>The Polygon Miden Architecture describes the concepts of how the participants of the network can interact.</p>
<p>The architecture reflects the design goals for the rollup:</p>
<ul>
<li><strong>High throughput</strong></li>
<li><strong>Privacy</strong></li>
<li><strong>Asset safety</strong></li>
</ul>
<h2 id="inspired-by-the-actor-model"><a class="header" href="#inspired-by-the-actor-model">Inspired by the Actor model</a></h2>
<p>The <a href="https://en.wikipedia.org/wiki/Actor_model">Actor Model</a> inspired Miden to achieve concurrent and local state changes. In the model, actors are little state machines with inboxes, meaning each actor is responsible for their own state. Actors can send and receive messages to communicate with other actors. Messages can be read asynchronously.</p>
<h2 id="core-concepts-in-miden"><a class="header" href="#core-concepts-in-miden">Core Concepts in Miden</a></h2>
<p>In Miden, there are accounts and notes which can hold assets. Accounts consume and produce notes in transactions. Transactions describe account state changes of single accounts.</p>
<h3 id="accounts"><a class="header" href="#accounts">Accounts</a></h3>
<p><a href="./architecture/accounts.html">Accounts</a> can hold assets and define rules how assets can be transferred. Accounts can represent users or autonomous smart contracts. This chapter describes the design, the storage types, and the creation of an account.</p>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<p><a href="./architecture/notes.html">Notes</a> are messages that accounts send to each other. A note stores assets and a script that defines how this note can be consumed. This chapter describes the design, the storage types, and the creation of a note.</p>
<h3 id="assets"><a class="header" href="#assets">Assets</a></h3>
<p><a href="./architecture/assets.html">Assets</a> can be fungible and non-fungible. They are stored in the owner’s account itself or in a note. This chapter describes asset issuance, customization, and storage.</p>
<h3 id="transactions"><a class="header" href="#transactions">Transactions</a></h3>
<p><a href="./architecture/transactions.html">Transactions</a> describe production and consumption of notes by a single account. Executing a transaction always results in a STARK proof. This chapter describes the transaction design and the implementation thereof. At it's core, transaction execution happens in the transaction kernel program which is explained in depth. </p>
<h4 id="accounts-produce-and-consume-notes-to-communicate"><a class="header" href="#accounts-produce-and-consume-notes-to-communicate">Accounts produce and consume notes to communicate</a></h4>
<p align="center">
    <img src="./diagrams/architecture/miden_architecture_core_concepts.gif" style="width: 80%;">
</p>
<h2 id="state-and-execution"><a class="header" href="#state-and-execution">State and Execution</a></h2>
<p>The state model captures all individual states of all accounts and notes. Finally, the execution model describes state progress in a sequence of blocks.</p>
<h3 id="state-model"><a class="header" href="#state-model">State model</a></h3>
<p><a href="./architecture/state.html">State</a> describes everything that is the case at a certain point in time. Individual states of accounts or notes can be stored onchain and offchain. This chapter describes the three different state databases in Miden.</p>
<h3 id="execution-model"><a class="header" href="#execution-model">Execution model</a></h3>
<p><a href="./architecture/execution.html">Execution</a> describes how the state progresses as aggregated state updates in batches, blocks, and epochs. This chapter describes the execution model and how blocks are built.</p>
<h4 id="operators-capture-and-progress-state"><a class="header" href="#operators-capture-and-progress-state">Operators capture and progress state</a></h4>
<p align="center">
    <img src="./diagrams/architecture/miden_architecture_state_progress.gif" style="width: 80%;">
</p>
<h1 id="architecture-tradeoffs"><a class="header" href="#architecture-tradeoffs">Architecture tradeoffs</a></h1>
<details>
  <summary>Want to know more on why we designed Miden as is?</summary>
<h3 id="polygon-midens-architecture"><a class="header" href="#polygon-midens-architecture">Polygon Miden's architecture</a></h3>
<p>Polygon Miden’s architecture departs considerably from typical blockchain designs to support privacy and parallel transaction execution. In traditional blockchains state and transactions must be transparent to be verifiable. This is necessary for block production and execution. User generated zero-knowledge proofs allow state transitions, e.g. transactions, to be verifiable without being transparent. </p>
<h3 id="actor-based-execution-model"><a class="header" href="#actor-based-execution-model">Actor-based execution model</a></h3>
<p>The actor model inspires Polygon Miden’s execution model. This is a well-known design paradigm in concurrent systems. In the actor model, actors are state machines responsible for maintaining their own state. In the context of Polygon Miden, each account is an actor. Actors communicate with each other by exchanging messages asynchronously. One actor can send a message to another, but it is up to the recipient to apply the requested change to their state. </p>
<p>Polygon Miden’s architecture takes the actor model further and combines it with zero-knowledge proofs. Now, actors not only maintain and update their own state, but they can also prove the validity of their own state transitions to the rest of the network. This ability to independently prove state transitions enables local smart contract execution, private smart contracts, and much more. And it is quite unique in the rollup space. Normally only centralized entities - sequencer or prover - create zero-knowledge proofs, not the users. </p>
<h3 id="hybrid-state-model"><a class="header" href="#hybrid-state-model">Hybrid state model</a></h3>
<p>The actor-based execution model requires a radically different approach to recording the system's state. Actors and the messages they exchange must be treated as first-class citizens. Polygon Miden addresses this by combining the state models of account-based systems like Ethereum and UTXO-based systems like Bitcoin and Zcash.</p>
</details><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="accounts-1"><a class="header" href="#accounts-1">Accounts</a></h1>
<p>Miden aims to support expressive smart contracts via a Turing-complete language. For smart contracts the go-to solution is account-based state. In Miden, an account is an entity which holds assets and defines rules of how these assets can be transferred. They are basic building blocks representing a user or an autonomous smart contract.</p>
<h2 id="account-design"><a class="header" href="#account-design">Account Design</a></h2>
<p>The diagram below illustrates basic components of an account. In Miden every account is a smart contract.</p>
<p align="center">
    <img src="architecture/../diagrams/architecture/account/Account_Definition.png" style="width: 25%;">
</p>
<p>In the above picture, you can see:</p>
<ul>
<li><strong>Account ID →</strong> a unique identifier of an account which does not change throughout its lifetime</li>
<li><strong>Storage →</strong> user-defined data which can be stored in an account</li>
<li><strong>Nonce →</strong> a counter which must be incremented whenever the account state changes</li>
<li><strong>Vault →</strong> a collection of assets stored in an account</li>
<li><strong>Code →</strong> a collection of functions which define the external interface for an account</li>
</ul>
<h3 id="account-id"><a class="header" href="#account-id">Account ID</a></h3>
<p>~63 bits (1 field element) long identifier for the account. The four most significant bits specify its <a href="https://0xpolygonmiden.github.io/miden-base/architecture/accounts.html#account-types">account type</a> - regular, immutable, faucet - and the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/accounts.html#account-storage-modes">storage mode</a> - public or private. </p>
<h3 id="account-storage"><a class="header" href="#account-storage">Account Storage</a></h3>
<p>Storage for user-defined data. <code>AccountStorage</code> is composed of two components.</p>
<p>The first component is a simple sparse Merkle tree of depth <code>8</code> which is index addressable. This provides the user with <code>256</code> <code>Word</code> slots.</p>
<p>Users requiring additional storage can use the second component a <code>MerkleStore</code>. It allows users to store any Merkle structures they need. The root of the Merkle structure can be stored as a leaf in a simple sparse Merkle tree. When <code>AccountStorage</code> is serialized it will check if any of the leafs in the simple sparse Merkle tree are Merkle roots of other Merkle structures. If any Merkle roots are found then the Merkle structures will be persisted in the <code>AccountStorage</code> <code>MerkleStore</code>.</p>
<h3 id="nonce"><a class="header" href="#nonce">Nonce</a></h3>
<p>Counter which must be incremented whenever the account state changes. Nonce values must be strictly monotonically increasing and can be incremented by any value smaller than 2^{32} for every account update.</p>
<h3 id="vault"><a class="header" href="#vault">Vault</a></h3>
<p>Asset container for an account.</p>
<p>An account vault can contain an unlimited number of <a href="https://0xpolygonmiden.github.io/miden-base/architecture/assets.html">assets</a>. The assets are stored in a sparse
Merkle tree as follows:</p>
<ul>
<li>For fungible assets, the index of a node is defined by the issuing faucet ID, and the value
of the node is the asset itself. Thus, for any fungible asset there will be only one node
in the tree.</li>
<li>For non-fungible assets, the index is defined by the asset itself, and the asset is also
the value of the node.</li>
</ul>
<p>An account vault can be reduced to a single hash which is the root of the sparse Merkle tree.</p>
<h3 id="code"><a class="header" href="#code">Code</a></h3>
<p>Interface for accounts. In Miden every account is a smart contract. It has an interface that exposes functions that can be called by <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-scripts">note scripts</a> and <a href="https://0xpolygonmiden.github.io/miden-base/transactions/transaction-kernel.html#the-transaction-script-processing">transaction scripts</a>. Users cannot call those functions directly. </p>
<p>Functions exposed by the account have the following properties:</p>
<ul>
<li>Functions are actually roots of <a href="https://0xpolygonmiden.github.io/miden-vm/user_docs/assembly/main.html">Miden program MASTs</a> (i.e., a 32-byte hash). Thus, function identifier is a commitment to the code which is executed when a function is invoked.</li>
<li>Only account functions have mutable access to an account's storage and vault. Therefore, the only way to modify an account's internal state is through one of the account's functions.</li>
<li>Account functions can take parameters and can create new notes.</li>
</ul>
<p><em>Note: Since code in Miden is expressed as MAST, every function is a commitment to the underlying code. The code cannot change unnoticed to the user because its hash would change. Behind any MAST root there can only be <code>256</code> functions</em></p>
<h4 id="example-account-code"><a class="header" href="#example-account-code">Example Account Code</a></h4>
<p>Currently, Miden provides two standard implementations for account code. </p>
<h5 id="basic-user-account-regular-updatable-account"><a class="header" href="#basic-user-account-regular-updatable-account">Basic user account (Regular updatable account)</a></h5>
<p>There is a standard for a basic user account. It exposes three functions via its interface.</p>
<details>
  <summary>Want to see the code?</summary>
<pre><code>  use.miden::contracts::wallets::basic-&gt;basic_wallet
  use.miden::contracts::auth::basic

  export.basic_wallet::receive_asset
  export.basic_wallet::send_asset
  export.basic::auth_tx_rpo_falcon512
</code></pre>
</details>
<p><a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-scripts">Note scripts</a> or <a href="https://0xpolygonmiden.github.io/miden-base/transactions/transaction-kernel.html#the-transaction-script-processing">transaction scripts</a> can call <code>receive_asset</code> and <code>send_asset</code> and in doing so, the account can receive and send assets. Transaction scripts can also call <code>auth_tx_rpo_falcon512</code> and authenticate the transaction. It is important to know, that without correct authentication, i.e. knowing the correct private key, a note cannot successfully invoke receive and send asset.</p>
<h5 id="basic-fungible-faucet-faucet-for-fungible-assets"><a class="header" href="#basic-fungible-faucet-faucet-for-fungible-assets">Basic fungible faucet (Faucet for fungible assets)</a></h5>
<p>There is also a standard for a <a href="https://github.com/0xPolygonMiden/miden-base/blob/main/miden-lib/asm/miden/contracts/faucets/basic_fungible.masm">basic fungible faucet</a>.</p>
<details>
  <summary>Want to see the code?</summary>
<pre><code>#! Distributes freshly minted fungible assets to the provided recipient.
#!
#! ...
export.distribute
    # get max supply of this faucet. We assume it is stored at pos 3 of slot 1
    push.METADATA_SLOT exec.account::get_item drop drop drop
    # =&gt; [max_supply, amount, tag, RECIPIENT, ...]

    # get total issuance of this faucet so far and add amount to be minted
    exec.faucet::get_total_issuance
    # =&gt; [total_issuance, max_supply, amount, tag, RECIPIENT, ...]

    # compute maximum amount that can be minted, max_mint_amount = max_supply - total_issuance
    sub
    # =&gt; [max_supply - total_issuance, amount, tag, RECIPIENT, ...]

    # check that amount =&lt; max_supply - total_issuance, fails if otherwise
    dup.1 gte assert
    # =&gt; [asset, tag, RECIPIENT, ...]

    # creating the asset
    exec.asset::create_fungible_asset
    # =&gt; [ASSET, tag, RECIPIENT, ...]

    # mint the asset; this is needed to satisfy asset preservation logic.
    exec.faucet::mint
    # =&gt; [ASSET, tag, RECIPIENT, ...]

    # create a note containing the asset
    exec.tx::create_note
    # =&gt; [note_ptr, ZERO, ZERO, ...]
end

#! Burns fungible assets.
#!
#! ...
export.burn
    # burning the asset
    exec.faucet::burn
    # =&gt; [ASSET]

    # increments the nonce (anyone should be able to call that function)
    push.1 exec.account::incr_nonce

    # clear the stack
    padw swapw dropw
    # =&gt; [...]
end
</code></pre>
</details>
<p>The contract exposes two functions <code>distribute</code> and <code>burn</code>. The first function <code>distribute</code> can only be called by the faucet owner, otherwise it fails. As inputs, the function expects everything that is needed to create a note containing the freshly minted asset, i.e., amount, <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-metadata">tag</a>, <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-recipient">RECIPIENT</a>.</p>
<p>The second function <code>burn</code> can be called by anyone to burn the tokens that are contained in a note.</p>
<p><em>Info: The difference is that the <code>burn</code> procedure exposes <code>exec.account::incr_nonce</code>, so by calling <code>burn</code> the nonce of the executing account gets increased by 1 and the transaction will pass the epilogue check. The <code>distribute</code> procedure does not expose that. That means the executing user needs to call <code>basic::auth_tx_rpo_falcon512</code> which requires the private key.</em></p>
<h2 id="account-creation"><a class="header" href="#account-creation">Account creation</a></h2>
<p>For an account to exist it must be present in the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/state.html#account-database">Account DB</a> kept by the Miden node(s). However, new accounts can be created locally by users using a wallet.</p>
<p>The process is as follows:</p>
<ul>
<li>Alice grinds a new Account ID (according to the account types) using a wallet</li>
<li>Alice's Miden client requests the Miden node to check if new Account ID already exists</li>
<li>Alice shares the new Account ID to Bob (eg. when Alice wants to receive funds)</li>
<li>Bob executes a transaction and creates a note that contains an asset for Alice</li>
<li>Alice consumes Bob's note to receive the asset in a transaction</li>
<li>Depending on the account storage mode (private vs. public) and transaction type (local vs. network) the Operator receives the new Account ID eventually and - if the transaction is correct - adds the ID to the Account DB</li>
</ul>
<p>For a user to create an account we have 2 solutions at the moment:</p>
<ol>
<li>Use the <a href="https://github.com/0xPolygonMiden/miden-client/tree/main">Miden client</a> as a wallet</li>
<li>Use the Miden Base builtin functions for wallet creation: <a href="https://github.com/0xPolygonMiden/miden-base/blob/4e6909bbaf65e77d7fa0333e4664be81a2f65eda/miden-lib/src/accounts/wallets/mod.rs#L15">Basic wallet</a>, <a href="https://github.com/0xPolygonMiden/miden-base/blob/4e6909bbaf65e77d7fa0333e4664be81a2f65eda/miden-lib/src/accounts/faucets/mod.rs#L11">Fungible faucet</a></li>
</ol>
<h2 id="account-types"><a class="header" href="#account-types">Account types</a></h2>
<p>There are four types of accounts in Miden:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Regular updatable account</th><th>Regular immutable account</th><th>Faucet for fungible assets</th><th>Faucet for non-fungible assets</th></tr></thead><tbody>
<tr><td><strong>Description</strong></td><td>For most users, e.g. a wallet. Code changes allowed, including public API.</td><td>For most smart contracts. Once deployed code is immutable.</td><td>Users can issue fungible assets and customize them.</td><td>Users can issue non-fungible assets and customize them.</td></tr>
<tr><td><strong>Code updatability</strong></td><td>yes</td><td>no</td><td>no</td><td>no</td></tr>
<tr><td><strong>Most significant bits</strong></td><td><code>00</code></td><td><code>01</code></td><td><code>10</code></td><td><code>11</code></td></tr>
</tbody></table>
</div>
<h2 id="account-storage-modes"><a class="header" href="#account-storage-modes">Account storage modes</a></h2>
<p>Account data - stored by the Miden node - can be public, private, or encrypted. The third and fourth most significant bits of the account ID specifies whether the account data is public <code>00</code>, encrypted <code>01</code>, or private <code>11</code>.</p>
<ul>
<li>Accounts with <strong>public state</strong>, where the actual state is stored onchain. These would be similar to how accounts work in public blockchains. Smart contracts that depend on public shared state should be stored public on Miden, e.g., DEX contract.</li>
<li>Accounts with <strong>private state</strong>, where only the hash of the account is stored onchain. Users who want stay private and take care of their own data should choose this mode. The hash is defined as: <code>hash([account ID, 0, 0, nonce], [vault root], [storage root], [code root])</code>.</li>
</ul>
<p>In the future we will also support <strong>encrypted state</strong> which will be onchain but encrypted. * Depending on the account storage mode (private vs. encrypted vs. public) and transaction type (local vs. network) the operator receives the new Account ID eventually and - if the transaction is correct - adds the ID to the Account DB</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="notes-1"><a class="header" href="#notes-1">Notes</a></h1>
<p>Miden aims to achieve parallel transaction execution and privacy. The UTXO-model combined with client-side proofs provide those features. That means, in Miden exist notes as a way of transferring assets between and to interact with accounts. Notes can be consumed and produced asynchronously and privately. The concept of notes is a key difference between Ethereum’s Account-based model and Polygon Miden, which uses a hybrid UTXO- and Account-based <a href="architecture/state.html">state-model</a>. </p>
<h1 id="note-design"><a class="header" href="#note-design">Note design</a></h1>
<p>In Polygon Miden, accounts communicate with one another by producing and consuming notes. A note stores assets and a script that defines how this note can be consumed. </p>
<p>The diagram below illustrates the contents of a note:</p>
<p align="center">
    <img src="architecture/../diagrams/architecture/note/Note.png" style="width: 25%;">
</p>
<p>As shown in the above picture:</p>
<ul>
<li><strong>Assets →</strong> serves as <a href="architecture/assets.html">asset</a> container for a note. It can contain up to <code>256</code> assets stored in an array which can be reduced to a single hash.</li>
<li><strong>Script →</strong> will be executed in the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/transactions.html">transaction</a> in which the note is consumed. The script defines the conditions for the consumption, if the script fails, the note cannot be consumed.</li>
<li><strong>Inputs →</strong> used for the note script execution. They can be accessed by the note script via <a href="https://0xpolygonmiden.github.io/miden-base/transactions/transaction-procedures.html#note">transaction kernel procedures</a>. The number is limited to 16 and they must be defined at note creation. </li>
<li><strong>Serial number →</strong> a note's unique identifier to break linkability between <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-hash">note hash</a> and <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-nullifier">nullifier</a>. Should be a random <code>Word</code> chosen by the user - if revealed, the nullifier might be computed easily.</li>
</ul>
<p>In addition, a note has <strong>metadata</strong> including the sender and the note tag. Those values are always public regardless of the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-storage-mode">note storage mode</a>.</p>
<h1 id="notes-lifecycle"><a class="header" href="#notes-lifecycle">Note's lifecycle</a></h1>
<p>New notes are created by executing transactions. After verifying the transaction proof the operator adds either only the note hash (private notes) or the full note data (public notes) to the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/state.html#notes-database">Note DB</a>. Notes can be produced and consumed locally by users in local transactions or by the operator in a network transaction. Note consumption requires the transacting party to know the note data to compute the nullifier. After successful verification, the operator sets the corresponding entry in the Nullifier DB to &quot;consumed&quot;. </p>
<p align="center">
    <img src="architecture/../diagrams/architecture/note/Note_life_cycle.png">
</p>
<p>The following sections will explain, how notes are created, stored, discovered and consumed. </p>
<h2 id="note-creation"><a class="header" href="#note-creation">Note creation</a></h2>
<p>Notes are created as outputs (<code>OutputNotes</code>) of Miden transactions. Operators record those notes to the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/state.html#note-database">Note DB</a>, after successful verification of the underlying transactions those notes can be consumed. </p>
<h2 id="the-note-script"><a class="header" href="#the-note-script">The note script</a></h2>
<p>Every note has a script which gets executed at note consumption. It is always executed in the context of a single account, and thus, may invoke zero or more of the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/accounts.html#code">account's functions</a>. The script allows for more than just the transferring of assets, they could be of arbitrary complexity thanks to the Turing completeness of the Miden VM</p>
<p>By design, every note script can be defined as a unique hash or the root of a <a href="https://0xpolygonmiden.github.io/miden-vm/user_docs/assembly/main.html">Miden program MAST</a>. That also means every function is a commitment to the underlying code. That code cannot change unnoticed to the user because its hash would change. That way it is easy to recognize standardized notes and those which deviate.</p>
<p>There exist <a href="https://github.com/0xPolygonMiden/miden-base/tree/main/miden-lib/asm/note_scripts">standard note scripts</a> (P2ID, P2IDR, SWAP) that users can create and add to their notes using the <a href="architecture/../network/miden-clients.html">Miden client</a> or by calling internal <a href="https://github.com/0xPolygonMiden/miden-base/blob/fa63b26d845f910d12bd5744f34a6e55c08d5cde/miden-lib/src/notes/mod.rs#L15-L66">Rust code</a>.</p>
<ul>
<li>P2ID and P2IDR scripts are used to send assets to a specific account ID. The scripts check at note consumption if the executing account ID equals the account ID that was set by the note creator as note inputs. The P2IDR script is reclaimable and thus after a certain block height can also be consumed by the sender itself. </li>
<li>SWAP script is a simple way to swap assets. It adds an asset from the note into the consumer's vault and creates a new note consumable by the first note's issuer containing the requested asset. </li>
</ul>
<h3 id="example-note-script-pay-to-id-p2id"><a class="header" href="#example-note-script-pay-to-id-p2id">Example note script Pay to ID (P2ID)</a></h3>
<details>
  <summary>Want to know more how to ensure a note can only be consumed by a specified account?</summary>
<h4 id="goal-of-the-p2id-script"><a class="header" href="#goal-of-the-p2id-script">Goal of the P2ID script</a></h4>
<p>The P2ID script defines a specific target account ID as the only account that can consume the note. Such notes ensure a targeted asset transfer. </p>
<h4 id="imports-and-context"><a class="header" href="#imports-and-context">Imports and context</a></h4>
<p>The P2ID script uses procedures from the account, note and wallet API.</p>
<pre><code>use.miden::account
use.miden::note
use.miden::contracts::wallets::basic-&gt;wallet
</code></pre>
<p>As discussed in detail in <a href="architecture/../transactions/transaction-procedures.html">transaction kernel procedures</a> certain procedures can only be invoked in certain contexts. The note script is being executed in the note context of the <a href="architecture/../transactions/transaction-kernel.html">transaction kernel</a>.</p>
<h4 id="main-script"><a class="header" href="#main-script">Main script</a></h4>
<p>The main part of the P2ID script checks if the executing account is the same as the account defined in the <code>NoteInputs</code>. The creator of the note defines the note script and the note inputs separately to ensure usage of the same standardized P2ID script regardless of the target account ID. That way, it is enough to check the script root (see above).</p>
<pre><code># Pay-to-ID script: adds all assets from the note to the account, assuming ID of the account
# matches target account ID specified by the note inputs.
#
# Requires that the account exposes: miden::contracts::wallets::basic::receive_asset procedure.
#
# Inputs: [SCRIPT_ROOT]
# Outputs: []
#
# Note inputs are assumed to be as follows:
# - target_account_id is the ID of the account for which the note is intended.
#
# FAILS if:
# - Account does not expose miden::contracts::wallets::basic::receive_asset procedure.
# - Account ID of executing account is not equal to the Account ID specified via note inputs.
# - The same non-fungible asset already exists in the account.
# - Adding a fungible asset would result in amount overflow, i.e., the total amount would be
#   greater than 2^63.
begin
    # drop the transaction script root
    dropw
    # =&gt; []
    
    # load the note inputs to memory starting at address 0
    push.0 exec.note::get_inputs
      # =&gt; [inputs_ptr]

    # read the target account id from the note inputs
    mem_load
    # =&gt; [target_account_id]

    exec.account::get_id
    # =&gt; [account_id, target_account_id, ...]

    # ensure account_id = target_account_id, fails otherwise
    assert_eq
    # =&gt; [...]

    exec.add_note_assets_to_account
    # =&gt; [...]
end
</code></pre>
<p>Every note script starts with the note script root on top of the stack. After the <code>dropw</code>, the stack is cleared. Next, the script stored the note inputs at pos 0 in the <a href="https://0xpolygonmiden.github.io/miden-base/transactions/transaction-procedures.html#transaction-contexts">relative note context memory</a> by  <code>push.0 exec.note::get_inputs</code>. Then, <code>mem_load</code> loads a <code>Felt</code> from the specified memory address and puts it on top of the stack, in that cases the   <code>target_account_id</code> defined by the creator of the note. Now, the note invokes <code>get_id</code> from the account API using <code>exec.account::get_id</code> - which is   possible even in the note context. Because, there are two account IDs on top of the stack now, <code>assert_eq</code> fails if the two account IDs (target_account_id and executing_account_id) are not the same. That means, the script cannot be successfully executed if executed by any other account than the account specified by the note creator using the note inputs.</p>
<p>If execution hasn't failed, the script invokes a helper procedure <code>exec.add_note_assets_to_account</code> to add the note's assets into the executing account's vault.</p>
<h4 id="add-assets"><a class="header" href="#add-assets">Add assets</a></h4>
<p>This procedure adds the assets held by the note into the account's vault. </p>
<pre><code>#! Helper procedure to add all assets of a note to an account.
#!
#! Inputs: []
#! Outputs: []
#!
proc.add_note_assets_to_account
    push.0 exec.note::get_assets
    # =&gt; [num_of_assets, 0 = ptr, ...]

    # compute the pointer at which we should stop iterating
    dup.1 add
    # =&gt; [end_ptr, ptr, ...]

    # pad the stack and move the pointer to the top
    padw movup.5
    # =&gt; [ptr, 0, 0, 0, 0, end_ptr, ...]

    # compute the loop latch
    dup dup.6 neq
    # =&gt; [latch, ptr, 0, 0, 0, 0, end_ptr, ...]

    while.true
        # =&gt; [ptr, 0, 0, 0, 0, end_ptr, ...]

        # save the pointer so that we can use it later
        dup movdn.5
        # =&gt; [ptr, 0, 0, 0, 0, ptr, end_ptr, ...]

        # load the asset and add it to the account
        mem_loadw call.wallet::receive_asset
        # =&gt; [ASSET, ptr, end_ptr, ...]

        # increment the pointer and compare it to the end_ptr
        movup.4 add.1 dup dup.6 neq
        # =&gt; [latch, ptr+1, ASSET, end_ptr, ...]
    end

    # clear the stack
    drop dropw drop
end
</code></pre>
<p>The procedure starts by calling <code>exec.note::get_assets</code>. As with the note's inputs before, this writes the assets of the note into memory starting at the specified address. Assets are stored in consecutive memory slots, so <code>dup.1 add</code> provides the last memory slot. </p>
<p>In Miden, <a href="architecture/assets.html">assets</a> are represented by <code>Words</code>, so we need to pad the stack with four <code>0</code>s to make room for an asset. Now, if there is at least one asset (checked by <code>dup dup.6 neq</code>), the loop starts. It first saves the pointer for later use (<code>dup movdn.5</code>), then loads the first asset <code>mem_loadw</code> on top of the stack. </p>
<p>Now, the procedure calls the a function of the account interface <code>call.wallet::receive_asset</code> to put the asset into the account's vault. Due to different <a href="https://0xpolygonmiden.github.io/miden-base/transactions/transaction-procedures.html#transaction-contexts">contexts</a>, a note script cannot directly call an account function to add the asset. The account must expose this function in its <a href="https://0xpolygonmiden.github.io/miden-base/architecture/accounts.html#example-account-code">interface</a>. </p>
<p>Lastly, the pointer gets incremented, and if there is a second asset, the loop continues (<code>movup.4 add.1 dup dup.6 neq</code>). Finally, when all assets were put into the account's vault, the stack is cleared (<code>drop dropw drop</code>).</p>
</details>
<h2 id="note-storage-mode"><a class="header" href="#note-storage-mode">Note storage mode</a></h2>
<p>Similar to accounts, there are two storage modes for notes in Miden. Notes can be stored on-chain in the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/state.html#notes-database">Note DB</a> with all data publicly visible for everyone. Alternatively, notes can be stored off-chain by committing only the note hash to the Note DB. </p>
<p>Every note has a unique note hash. It is defined as follows:</p>
<pre><code>hash(hash(hash(hash(serial_num, [0; 4]), script_hash), input_hash), vault_hash)
</code></pre>
<p><em>Info: To compute a note's hash, we do not need to know the note's <code>serial_num</code>. Knowing the hash of the <code>serial_num</code> (as well as <code>script_hash</code>, <code>input_hash</code> and <code>note_vault</code>) is also sufficient. We compute the hash of <code>serial_num</code> as <code>hash(serial_num, [0; 4])</code> to simplify processing within the VM.</em></p>
<h2 id="note-discovery"><a class="header" href="#note-discovery">Note discovery</a></h2>
<p>Note discovery describes the process of Miden clients finding notes they want to consume. There are two ways to receive new relevant notes - getting notes via an off-chain channel or querying the Miden operator to request newly recorded relevant notes. 
The latter is done via note tags. Tags are part of the note's metadata and are represented by a <code>Felt</code>. The <code>SyncState</code> API of the <a href="architecture/../network/miden-node.html">Miden node</a> requires the Miden client to provide a <code>note_tag</code> value which is used as a filter in the operator's response. Tags are useful for note discovery enabling an easy collection of all notes matching a certain tag.</p>
<h2 id="note-consumption"><a class="header" href="#note-consumption">Note consumption</a></h2>
<p>As with creation, notes can only be consumed in Miden transactions. If a valid transaction consuming an <code>InputNote</code> gets verified by the Miden node, the note's unique nullifier gets added to the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/state.html#nullifier-database">Nullifier DB</a> and is therefore consumed. </p>
<p>Notes can only be consumed if the note data is known to the consumer. The note data must be provided as input to the <a href="architecture/../transactions/transaction-kernel.html">transaction kernel</a>. That means, for privately stored notes, there must be some off-chain communication to transmit the note's data from the sender to the target.</p>
<h3 id="note-recipient-to-restrict-note-consumption"><a class="header" href="#note-recipient-to-restrict-note-consumption">Note recipient to restrict note consumption</a></h3>
<p>There are several ways to restrict the set of accounts that can consume a specific note. One way is to specifically define the target account ID as done in the P2ID and P2IDR note scripts. Another way is by using the concept of a <code>RECIPIENT</code>. Miden defines a <code>RECIPIENT</code> (represented as <code>Word</code>) as: </p>
<pre><code>hash(hash(hash(serial_num, [0; 4]), script_hash), input_hash)
</code></pre>
<p>This concept restricts note consumption to those users who know the pre-image data of <code>RECIPIENT</code> - which might be a bigger set than a single account.</p>
<p>During the <a href="architecture/../transactions/transaction-kernel.html">transaction prologue</a> the users needs to provide all the data to compute the note hash. That means, one can create notes that can only be consumed if the <code>serial_num</code> and other data is known. This information can be passed on off-chain by the sender to the consumer. This is only useful with private notes.For public notes, all note data is known, and anyone can compute the <code>RECIPIENT</code>. </p>
<p>You can see in the standard <a href="https://github.com/0xPolygonMiden/miden-base/blob/main/miden-lib/asm/note_scripts/SWAP.masm">SWAP note script</a> how <code>RECIPIENT</code> is used. Here, using a single hash, is sufficient to ensure that the swapped asset and its note can only be consumed by the defined target.</p>
<h3 id="note-nullifier-to-ensure-private-consumption"><a class="header" href="#note-nullifier-to-ensure-private-consumption">Note nullifier to ensure private consumption</a></h3>
<p>The note's nullifier is computed as: </p>
<pre><code>hash(serial_num, script_hash, input_hash, vault_hash)
</code></pre>
<p>This achieves the following properties:</p>
<ul>
<li>Every note can be reduced to a single unique nullifier.</li>
<li>One cannot derive a note's hash from its nullifier.</li>
<li>To compute the nullifier, one must know all components of the note: <code>serial_num</code>, <code>script_hash</code>, <code>input_hash</code>, and <code>vault_hash</code>.</li>
</ul>
<p>That means if a note is private and the operator stores only the note's hash, only those with the note details know if this note has been consumed already. Zcash first <a href="https://zcash.github.io/orchard/design/nullifiers.html#nullifiers">introduced</a> this approach.</p>
<p align="center">
    <img src="architecture/../diagrams/architecture/note/Nullifier.png">
</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="assets-1"><a class="header" href="#assets-1">Assets</a></h1>
<p>In Miden, users can create and trade arbitrary fungible and non-fungible assets.</p>
<p>We differentiate between native and non-native assets in Miden. Native assets follow the Miden asset model. Non-native assets are all other data structures of value that can be exchanged.</p>
<p>Recording of native assets in Polygon Miden suffices four goals:</p>
<ul>
<li>Asset exchange should be parallelizable</li>
<li>Asset ownership should be private</li>
<li>Asset usage should be indeed censorship resistant</li>
<li>Fees can be paid using any asset</li>
</ul>
<p>All native assets in Miden are stored directly in accounts, like Ether in Ethereum. Miden does not track ownership of assets using global hashmaps, e.g., ERC20 contracts. Storage of assets locally in accounts provides privacy and the ability for client-side proofs. That is because ownership changes always involve only one account and not the change of a global hashmap. Thus, they can happen in parallel. Additionally, asset exchange is censorship resistant at this level because there is no global contract the transfer must pass through. Finally, users can pay fees in any asset.</p>
<h2 id="native-assets"><a class="header" href="#native-assets">Native assets</a></h2>
<p>Native assets are data structures that follow the Miden asset model (encoding, issuance, storing). All native assets are encoded using a single <code>Word</code> (4 field elements). The asset encodes both the ID of the issuing account and the asset details. Having the issuer's ID encoded in the asset makes it cost-efficient to determine the type of an asset inside and outside Miden VM. And, representing the asset in a <code>Word</code> means the representation is always a commitment to the asset data itself. That is particularly interesting for non-fungible assets.</p>
<h3 id="issuance"><a class="header" href="#issuance">Issuance</a></h3>
<p>Only specialized accounts called faucets can issue assets. Just like with regular accounts, anyone can create a faucet account. Faucets can issue only either fungible or non-fungible assets - but not both. The <code>faucet_id</code> identifies the faucet and is starts with a different sequence depending on the asset type, see <a href="https://0xpolygonmiden.github.io/miden-base/architecture/accounts.html#account-id">here</a>. The faucet's code defines rules for how assets can be minted, who can mint them etc. Conceptually, faucet accounts on Miden are similar to ERC20 contracts on Ethereum. But, there is no ownership tracking in Miden faucets.</p>
<p>Faucets can create assets and immediately distribute them by producing notes. However, assets can also stay in the faucet after creation to be sent later, e.g., in a bundle. That way, one can mint a million NFTs locally in a single transaction and then send them out as needed in separate transactions in the future.</p>
<p align="center">
    <img src="architecture/../diagrams/architecture/asset/Asset_Issuance.png" style="width: 50%;">
</p>
<h3 id="fungible-assets"><a class="header" href="#fungible-assets">Fungible assets</a></h3>
<p>A fungible asset is encoded using the amount and the <code>faucet_id</code> of the faucet which issued the asset. The amount is guaranteed to be  <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">63</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> or smaller, the maximum supply for any fungible asset. Examples of fungible assets are ETH and stablecoins, e.g., DAI, USDT, and USDC.</p>
<p>If the <code>faucet_id</code> of MATIC were to be <code>2</code>, 100 MATIC are encoded as <code>[100, 0, 0, 2]</code> - whereas the <code>0</code>s in the middle help to quickly distinguish between fungible and non-fungible assets.</p>
<h3 id="non-fungible-assets"><a class="header" href="#non-fungible-assets">Non-fungible assets</a></h3>
<p>A non-fungible asset is encoded by hashing the asset data into a <code>Word</code> and then replacing the second element with the <code>faucet_id</code> of the issuing account. It looks like <code>[e0, faucet_id, e2, e3]</code>. Note that the second element is guaranteed to be non-Zero.</p>
<p>Examples of non-fungible assets are all NFTs, e.g., a DevCon ticket. The ticket's data might be represented in a JSON string - which DevCon, the date, the initial price, etc. . Now, users can create a faucet for non-fungible DevCon tickets. This DevCon faucet would hash the JSON string into a <code>Word</code> to transform the ticket into an asset.</p>
<h3 id="storage"><a class="header" href="#storage">Storage</a></h3>
<p><a href="https://0xpolygonmiden.github.io/miden-base/architecture/accounts.html">Accounts</a> and <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html">notes</a> contain asset vaults that are used to store assets. Accounts can keep unlimited assets in a <a href="https://0xpolygonmiden.github.io/miden-base/crypto-primitives/tsmt.html">tiered sparse Merkle tree</a> called <code>account vault</code>. Notes can only store up to <code>255</code> distinct assets.</p>
<p align="center">
    <img src="architecture/../diagrams/architecture/asset/Asset_Storage.png" style="width: 50%;">
</p>
<p>The information on which and how many assets are owned can be private depending on the account's or note's storage mode. This is true for any native asset in Miden.</p>
<h2 id="non-native-assets"><a class="header" href="#non-native-assets">Non-native assets</a></h2>
<p>Miden is flexible enough to create other types of assets as well.</p>
<p>For example, developers can fully replicate Ethereum's ERC20 model, where ownership of fungible assets is recorded in a single account. To transact, users must send a note to that account to change the global hashmap.</p>
<p>Furthermore, a complete account can be treated as a programmable asset because ownership of accounts is transferrable. An account could be a &quot;crypto kitty&quot; with specific attributes and rules, and people can trade these &quot;crypto kitties&quot; by transferring accounts between each other.</p>
<p>We can also think of an account representing a car. The owner of the car can change so the car account - granting access to the physical car - can be treated as an asset. In this car account, there could be rules defining who is allowed to drive the car and when.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="transactions-1"><a class="header" href="#transactions-1">Transactions</a></h1>
<p>Transactions in Miden can be understood as facilitating account state changes. Asset transfers between accounts are done by executing transactions. They take a single account and some <a href="architecture/notes.html">notes</a> as input and output the same account at a new state together with some other notes. </p>
<p>Miden aims for parallel and private transaction execution. Because a transaction is always performed against a single account, Miden obtains asynchronicity. And, because every transaction causes a provable state-change with a STARK proof, it provides privacy when executed locally.</p>
<h2 id="transaction-design"><a class="header" href="#transaction-design">Transaction design</a></h2>
<p>Transactions describe the state-transition of a single account that takes chain data and <code>0 to 1023</code> notes as input and produces a <code>TransactionWitness</code> and <code>0 to 4096</code> notes as output.</p>
<p><br />
</p>
<p align="center">
    <img src="architecture/../diagrams/architecture/transaction/Transaction_diagram.png" style="width: 75%;">
</p>
<p><br />
</p>
<p>At its core, a transaction is an executable program - the transaction kernel program - that processes the provided inputs and creates the requested outputs. Because the program is executed by the Miden VM, a STARK-proof is generated for every transaction.</p>
<p>The next sections will explain the details of a Miden transaction </p>
<ul>
<li>Transaction <a href="architecture/../transactions/transaction-execution.html">execution</a> </li>
<li>Transaction <a href="architecture/../transactions/transaction-kernel.html">kernel</a></li>
<li>Transaction <a href="architecture/../transactions/transaction-procedures.html">procedures</a></li>
<li>Transaction <a href="architecture/../transactions/transaction-modes.html">modes</a></li>
</ul>
<h2 id="asset-transfer-using-two-transactions"><a class="header" href="#asset-transfer-using-two-transactions">Asset transfer using two transactions</a></h2>
<p>Transferring assets between accounts requires two transactions as shown in the diagram below.</p>
<p align="center">
    <img src="architecture/../diagrams/architecture/transaction/Transaction_Flow.png">
</p>
<p>The first transaction invokes a function on <code>account_a</code> (e.g., &quot;send_asset&quot; function) which creates a new note and also updates the internal state of <code>account_a</code>. The second transaction consumes the note which invokes a function on <code>account_b</code> (e.g., &quot;receive_asset&quot; function), which also updates the internal state of <code>account_b</code>.</p>
<p>It is important to note that both transactions can be executed asynchronously: first <code>transaction1</code> is executed, and then, some time later, <code>transaction2</code> can be executed. This opens up a few interesting possibilities:</p>
<ul>
<li>Owner of <code>account_b</code> may wait until they receive many notes and process them all in a single transaction.</li>
<li>A note script may include a clause which allows the source account to consume the note after some time. Thus, if <code>account_b</code> does not consume the note after the specified time, the funds can be returned. This mechanism could be used to make sure funds sent to non-existent accounts are not lost.</li>
<li>Neither sender nor the recipient need to know who the other side is. From the sender's perspective they just need to create <code>note1</code> (and for this they need to know the assets to be transferred and the root of the note's script). They don't need any information on who will eventually consume the note. From the recipient's perspective, they just need to consume <code>note1</code>. They don't need to know who created it.</li>
<li>Both transactions can be executed &quot;locally&quot;. For example, we could generate a zk-proof that <code>transaction1</code> was executed and submit it to the network. The network can verify the proof without the need for executing the transaction itself. The same can be done for <code>transaction2</code>. Moreover, we can mix and match. For example, <code>transaction1</code> can be executed locally, but <code>transaction2</code> can be executed on the network, or vice-versa.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="transaction-execution"><a class="header" href="#transaction-execution">Transaction Execution</a></h1>
<p>Transactions are being executed by the Miden Transaction Executor. Transaction execution results in a <code>ExecutedTransaction</code> object and consists of the following steps:</p>
<ol>
<li>Fetch the data required to execute a transaction from the data store.</li>
<li>Compile the transaction into an executable <a href="https://0xpolygonmiden.github.io/miden-vm/user_docs/assembly/main.html">MASM</a> program using the transaction compiler.</li>
<li>Execute the transaction program and create an <code>ExecutedTransaction</code> object.</li>
<li>Prove the <code>ExecutedTransaction</code> using the Transaction Prover.</li>
</ol>
<p align="center">
    <img src="transactions/../diagrams/architecture/transaction/Transaction_execution_process.png" style="width: 75%;">
</p>
<p>One of the main reasons for splitting execution and proving is that it allows to have &quot;stateless provers&quot; - i.e., the executed transaction contains all data needed to re-execute and prove a transaction (no database access is needed). This is very powerful and allows the distribution of proof generation much more easily.</p>
<h2 id="the-data-store-and-transaction-inputs"><a class="header" href="#the-data-store-and-transaction-inputs">The Data Store and Transaction Inputs</a></h2>
<p>The data store defines the interface that transaction objects use to fetch data required for transaction execution. It stores account, chain, and input note data required to execute a transaction against the account with the specified ID.</p>
<p>Specifically, it must provide the following inputs to the transaction </p>
<ul>
<li>the <code>Account</code> including the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/accounts.html#account-id">AccountID</a> and the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/accounts.html#code">AccountCode</a> which will be executed during the transaction. </li>
<li>the <code>BlockHeader</code>, which contains metadata about the block, commitments to the current state of the chain and the hash of the proof that attests to the integrity of the chain.</li>
<li>the <code>ChainMmr</code>, which allows for efficient authentication of consumed notes during transaction execution. Authentication is achieved by providing an inclusion proof for the consumed notes in the transaction against the <code>ChainMmr</code>-root associated with the latest block known at the time of transaction execution.</li>
<li>the <code>InputNotes</code> that are being consumed in the transaction (InputNotes), including the corresponding note data, e.g. the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#script">note script</a> and <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#serial-number">serial number</a>.</li>
</ul>
<p><em>Note: The <code>InputNotes</code> must all be already recorded on-chain in order for the transaction to succeed. And there is no Nullifier-check during a transaction. Nullifiers are being checked by the Miden Operator during transaction verification. So at the transaction level, there is &quot;double spending&quot;.</em></p>
<h2 id="the-transaction-compiler"><a class="header" href="#the-transaction-compiler">The Transaction Compiler</a></h2>
<p>Every transaction must be executed within the Miden VM to generate a transaction proof. In Miden there is a proof for every transaction. The transaction compiler is responsible for building executable programs. The generated programs - MASM programs - can then be executed on the Miden VM which generates a zkProof. In addition to transaction compilation, the transaction compiler provides methods which can be used to compile Miden account code, note scripts, and transaction scripts. </p>
<p>Compilation results in an executable MASM Program, including the provided account interface and notes, an optional transaction script and the <a href="transactions/transaction-kernel.html">Transaction Kernel Program</a>. The Transaction Kernel Program defines procedures and the memory layout for all parts of the transaction. A detailed description can be found in the next section. </p>
<p>Finally, after the transaction program has been compiled and the inputs including the advice provider were correctly populated, the transaction can be executed.</p>
<h2 id="the-executed-transaction-and-the-transaction-outputs"><a class="header" href="#the-executed-transaction-and-the-transaction-outputs">The Executed Transaction and the Transaction Outputs</a></h2>
<p>The <code>ExecutedTransaction</code> object represents the result of a transaction - not its proof yet. From it, the account, and storage delta can be extracted. Furthermore, it serves as an input of the transaction prover to generate the proof. A successfully executed transaction results in a new state of the provided account, a vector of all created Notes (<code>OutputNotes</code>) and a vector of all the consumed Notes (<code>InputNotes</code>) together with their Nullifiers.</p>
<h2 id="the-transaction-prover"><a class="header" href="#the-transaction-prover">The Transaction Prover</a></h2>
<p>The Transaction Prover proves the provided <code>ExecutedTransaction</code> and returns a <code>ProvenTransaction</code> object. This object can be verified by the Miden Node using the Transaction Verifier and if valid updating the <a href="transactions/../architecture/state.html">State</a> databases.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="the-transaction-kernel-program"><a class="header" href="#the-transaction-kernel-program">The Transaction Kernel Program</a></h1>
<p>The transaction kernel program is responsible to execute a Miden rollup transaction within the Miden VM. Therefore, it is written in <a href="https://0xpolygonmiden.github.io/miden-vm/user_docs/assembly/main.html">MASM</a> and it is defined as MASM <a href="https://0xpolygonmiden.github.io/miden-vm/user_docs/assembly/execution_contexts.html#kernels">kernel</a>. The kernel provides context-sensitive security preventing unwanted read and write access. It defines a set of procedures which can be invoked from other <a href="https://0xpolygonmiden.github.io/miden-vm/user_docs/assembly/execution_contexts.html#execution-contexts">contexts</a> - e.g., notes - to be executed in the root context.</p>
<p>In general, the kernel's procedures must reflect everything users might want to do in executing transactions, from transferring assets to complex smart contract interactions with custom code. Learn more about available procedures and contexts <a href="transactions/transaction-procedures.html">here</a>.</p>
<p>The kernel has a well-defined structure which must do the following:</p>
<ol>
<li><strong>Prologue</strong>: prepares the transaction for processing by parsing the transaction data and setting up the root context.</li>
<li><strong>Note Processing</strong>: executes the note processing loop which consumes each InputNote and invokes the note script of each note.</li>
<li><strong>Transaction Script Processing</strong>: executes the optional transaction script.</li>
<li><strong>Epilogue</strong>: finalizes the transaction by computing the created notes commitment, the final account hash, asserting asset invariant conditions and asserting the nonce rules are upheld.</li>
</ol>
<p align="center">
    <img src="transactions/../diagrams/architecture/transaction/Transaction_program.png" style="width: 75%;">
</p>
<h2 id="the-inputs"><a class="header" href="#the-inputs">The Inputs</a></h2>
<p>The transaction kernel program receives two type of inputs, public inputs via the <code>operand_stack</code> and secret inputs via the <code>advice_provider</code>. The stack holds the global inputs. They serve as a commitment to the data being provided via the advice provider. The advice stack holds data of the last known block, account and input note data. The details are layed out in the next paragraph.</p>
<h2 id="the-prologue"><a class="header" href="#the-prologue">The Prologue</a></h2>
<p>The transaction prologue is executed at the beginning of a transaction. It needs to accomplish the following tasks:</p>
<ol>
<li>&quot;Unhash&quot; the inputs and lay them out in root context's memory.</li>
<li>Build a single vault (&quot;tx vault&quot;) containing assets of all inputs (input notes and initial account state).</li>
<li>Verify that all input notes are present in the Note DB.</li>
</ol>
<p>In other words, the prologue stores all provided information from the inputs and the advice provider into the appropriate memory slots. It then reads the data for account and notes from the advice provider, writes it to memory, hashes it, and verifies that the resulting hash matches the commitments provided via the stack. Finally, it creates a single vault for the assets that are involved. </p>
<p>The memory layout looks as follows. The kernel context has access to all of those memory slots. </p>
<p align="center">
    <img src="transactions/../diagrams/architecture/transaction/Memory_layout_kernel.png" style="width: 75%;">
</p>
<p>The book keeping section is needed to keep track of variables which are used internally by the transaction kernel. </p>
<p>First, all <strong>global inputs</strong> are being stored in the pre-defined memory slots. Global inputs are being provided via the <code>operand_stack</code> to the VM at transaction execution. The include the block hash, the account ID, the initial account hash, and the Nullifier commitment. This is a sequential hash of all <code>(nullifier, ZERO)</code> pairs for the notes consumed in the transaction.</p>
<p>Second, the <strong>block data</strong> is being processed. This involves reading the block data from the advice provider and storing it at the appropriate memory addresses. Block data is provided from the latest known block and consists of note, state and batch root, the block;s the previous hash and proof hash, as well as the block number. As the data is read from the advice provider, the block hash is computed. It is asserted that the computed block hash matches the block hash stored in the global inputs.</p>
<p>Third, the <strong>chain data</strong> is being processed in a similar way as the block data. In this case the chain root is being recomputed and compared against the chain root stored in the block data section. </p>
<p>Fourth, the <strong>account data</strong> is being processed. This involves reading the data from the advice provider and storing it at the appropriate memory addresses. The account data consists of roots of the account's vault, its storage and code. As the account data is read from the advice provider, the account hash is computed. If the account is new then the global initial account hash is updated and the new account is validated.  If the account already exists then it is asserted that the computed account hash matches the account hash provided via global inputs. It is also asserted that the account id matches the account id provided via the global inputs (<code>operand_stack</code>).</p>
<p>Fifth, the <strong>input notes</strong> are being processed. This involves per note reading the data from the advice provider and storing it at the appropriate memory addresses. Next to the total number of consumed notes, input note data consists of its serial number, the roots of the script, inputs and asset vault, its metadata and all its assets. As each note is consumed its hash and nullifier is computed. The transaction Nullifier commitment is computed via a sequential hash of all <code>(nullifier, ZERO)</code> pairs for all consumed notes. This step involves authentication that the input note data provided via the advice provider is consistent with the chain history. </p>
<p><em>Note: One needs to provide the note data to compute the Nullifier, e.g. the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#script">note script</a> and the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#serial-number">serial number</a>. So one needs to know the note data to execute the prologue of a transaction. This is how the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-recipient">note recipient</a> defines the set of users who can consume a specific note. The executing account needs to provide the pre-image data to the recipient at the time of execution.</em></p>
<p>Lastly, if a transaction script is provided, its root is being stored at the pre-defined memory address. </p>
<h2 id="the-note-processing"><a class="header" href="#the-note-processing">The Note Processing</a></h2>
<p>If there are input notes they are being consumed in a loop. For every note, the <a href="https://0xpolygonmiden.github.io/miden-vm/design/programs.html">MAST root</a> of the note script is being loaded onto the stack. Then, by calling a <a href="https://0xpolygonmiden.github.io/miden-vm/user_docs/assembly/code_organization.html?highlight=dyncall#dynamic-procedure-invocation"><code>dyncall</code></a> the note script is being executed in a new context to prevent unwanted memory access. </p>
<pre><code>    # loop while we have notes to consume
    while.true
        # execute the note setup script
        exec.note::prepare_note
        # =&gt; [NOTE_SCRIPT_HASH]

        # invoke the note script using the dyncall instruction
        dyncall
        # =&gt; [OUTPUT_3, OUTPUT_2, OUTPUT_1, OUTPUT_0]

        # clean up note script outputs
        dropw dropw dropw dropw
        # =&gt; []

        # check if we have more notes to consume and should loop again
        exec.note::increment_current_consumed_note_ptr
        loc_load.0
        neq
        # =&gt; [should_loop]
    end
</code></pre>
<p>In processing a note, the creation of a new note might be triggered. If so, all necessary information about the new note is being stored in the <em>output note data</em> in memory.</p>
<p><em>Note: The Miden Transaction Kernel Program prevents notes from having direct access to account storage. Notes can only call the account interface to trigger write operations in the account.</em></p>
<h2 id="the-transaction-script-processing"><a class="header" href="#the-transaction-script-processing">The Transaction Script Processing</a></h2>
<p>If there is a transaction script provided with the transaction, it will be processed after all notes are being consumed. By loading the transaction script root onto the stack the kernel can invoke a <code>dyncall</code> and in doing so execute the script. The transaction script is again being executed in its own context.</p>
<p>The transaction script can be used to authenticate the transaction by increasing the account's nonce and signing the transaction, see the following example:</p>
<pre><code>    use.miden::contracts::auth::basic-&gt;auth_tx

    begin
        call.auth_tx::auth_tx_rpo_falcon512
    end
</code></pre>
<p><em>Note: The executing account must expose the <code>auth_tx_rpo_falcon512</code> function in order for the transaction script to call it.</em></p>
<h2 id="the-epilogue"><a class="header" href="#the-epilogue">The Epilogue</a></h2>
<p>The Epilogue finalizes the transaction. It </p>
<ol>
<li>computes the final account hash</li>
<li>if the account has changed, assert that the final account nonce is greater than the initial
account nonce</li>
<li>computes the created notes commitment</li>
<li>asserts that the input and output vault roots are equal</li>
</ol>
<p>There is an exception for special accounts, called faucets, which can mint or burn assets. In that case input and output vault roots are not equal. </p>
<h2 id="the-outputs"><a class="header" href="#the-outputs">The Outputs</a></h2>
<p>The transaction kernel program outputs the transaction script root, a commitment of all newly created outputs notes, and the account hash in its new state. </p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="transaction-contexts"><a class="header" href="#transaction-contexts">Transaction Contexts</a></h1>
<p>Miden assembly program execution can span multiple isolated contexts. An execution context defines its own memory space which is not accessible from other execution contexts. Note scripts cannot directly write into account data. This should be possible if only if the account exposes respective functions.</p>
<p>The kernel program always starts executing in a root context. Thus, the prologue sets the memory for the root context. To move execution into a different context, we can invoke a procedure using the <code>call</code> or <code>dyncall</code> instruction. In fact, any time we invoke a procedure using the <code>call</code> instruction, the procedure is executed in a new context. </p>
<p>While executing in a note, account, or tx script context, we can request to execute some procedures in the kernel context, which is where all necessary information was stored during the prologue. Switching to the kernle context can be done via the <code>syscall</code> instruction. The set of procedures which can be invoked via the <code>syscall</code> instruction is limited by the <a href="https://github.com/0xPolygonMiden/miden-base/blob/main/miden-lib/asm/kernels/transaction/api.masm">transaction kernel API</a>. Once the procedure call via <code>syscall</code> returns, the execution moves back to the note, account, or tx script from which it was invoked.</p>
<p><br />
</p>
<p align="center">
    <img src="transactions/../diagrams/architecture/transaction/Transaction_contexts.png" style="width: 100%;">
</p>
<p><br />
</p>
<p>The above diagram shows different context switches in a simple transaction. In this example, an account consumes a <a href="https://github.com/0xPolygonMiden/miden-base/blob/main/miden-lib/asm/note_scripts/P2ID.masm">P2ID</a> note and receives the asset into its vault. As with in any MASM program, the transaction kernel program starts in the root context. It executes the Prologue and stores all necessary information into the root memory. </p>
<p>The next step, note processing, starts with a <code>dyncall</code> and in doing so, invoking the note script. This command moves execution into a different context <strong>(1)</strong>. In this new context, the note has no access to the kernel memory. After a successful ID check, which changes back to the kernel context twice to get the note inputs and the account id, the script executes the <code>add_note_assets_to_account</code> procedure.</p>
<pre><code># Pay-to-ID script: adds all assets from the note to the account, assuming ID of the account
# matches target account ID specified by the note inputs.
# ...
begin
    
    ... &lt;check correct ID&gt;

    exec.add_note_assets_to_account
    # =&gt; [...]
end
</code></pre>
<p>The procedure cannot simply add assets to the account, because it is executed in a note context. Therefore, it needs to <code>call</code> the account interface. And in doing so, it moves execution into a second context - Account context - isolated from the note context <strong>(2)</strong>. </p>
<pre><code>#! Helper procedure to add all assets of a note to an account.
#! ...
proc.add_note_assets_to_account
    ...

    while.true
        ...

        # load the asset and add it to the account
        mem_loadw call.wallet::receive_asset
        # =&gt; [ASSET, ptr, end_ptr, ...]
        ...
    end
    ...
end
</code></pre>
<p>The <a href="https://github.com/0xPolygonMiden/miden-base/blob/main/miden-lib/asm/miden/contracts/wallets/basic.masm">wallet</a> smart contract provides an interface for accounts to recieve and send assets. In this new context, the wallet calls the <code>add_asset</code> procedure of the account API. </p>
<pre><code>export.receive_asset
    exec.account::add_asset
    ...
end
</code></pre>
<p>The <a href="https://github.com/0xPolygonMiden/miden-base/blob/main/miden-lib/asm/miden/account.masm#L162">account API</a> exposes procedures to manage accounts. This particular procedure that was called by the wallet invokes a <code>syscall</code> to return back to the root context <strong>(3)</strong>, where the account vault is stored in memory (see Prologue). <code>syscall</code> can incoke all procedures defined in the <a href="https://github.com/0xPolygonMiden/miden-base/blob/main/miden-lib/asm/kernels/transaction/api.masm">Kernel API</a>.</p>
<pre><code>#! Add the specified asset to the vault.
#! ...
export.add_asset
    syscall.account_vault_add_asset
end
</code></pre>
<p>Now, the asset can be safely added to the vault within the kernel context and the note successfully be processed. </p>
<h1 id="transaction-procedures"><a class="header" href="#transaction-procedures">Transaction Procedures</a></h1>
<p>There are user-facing procedures and kernel procedures. Users don't directly invoke kernel procedures, but indirectly via account code, note or transaction scripts. In that case, kernel procedures can only be invoked by a <code>syscall</code> instruction which always executes in the kernel context. </p>
<h2 id="user-facing-procedures-apis"><a class="header" href="#user-facing-procedures-apis">User-facing Procedures (APIs)</a></h2>
<p>These procedures can be used to create smart contract / account code, note scripts or account scripts. They basically serve as an API for the underlying kernel procedures. If a procedure can be called in the current context an <code>exec</code> is sufficient, otherwise if being the wrong context procedures must be invoked by <code>call</code>. Users will never need to invoke <code>syscall</code> procedures themselves. </p>
<p><em>Note: If capitalized, a variable represents a <code>Word</code>, e.g., <code>ACCT_HASH</code> consists of four <code>Felts</code>. If lowercase, the variable is represented by a single <code>Felt</code>.</em></p>
<h3 id="account"><a class="header" href="#account">Account</a></h3>
<p>To import the account procedures set <code>use.miden::account</code> at the beginning of the file. Any procedure that changes the account state, can only be invoked in the account context and not by note or transaction scripts. All procedures invoke <code>syscall</code> to the kernel API and some are restricted by the kernel procedure <code>exec.authenticate_account_origin</code>, which fails if the parent context is not the executing account.</p>
<div class="table-wrapper"><table><thead><tr><th>Procedure name</th><th>Stack</th><th>Output</th><th>Context</th><th>Description</th></tr></thead><tbody>
<tr><td><code>get_id</code></td><td><code>[]</code></td><td><code>[acct_id]</code></td><td>account, note</td><td><details><summary>View</summary>Returns the account id. acct_id is the account id.</details></td></tr>
<tr><td><code>get_nonce</code></td><td><code>[]</code></td><td><code>[nonce]</code></td><td>account, note</td><td><details><summary>View</summary>Returns the account nonce. nonce is the account nonce.</details></td></tr>
<tr><td><code>get_initial_hash</code></td><td><code>[]</code></td><td><code>[H]</code></td><td>account, note</td><td><details><summary>View</summary>Returns the initial account hash. H is the initial account hash.</details></td></tr>
<tr><td><code>get_current_hash</code></td><td><code>[]</code></td><td><code>[ACCT_HASH]</code></td><td>account, note</td><td><details><summary>View</summary>Computes and returns the account hash from account data stored in memory. ACCT_HASH is the hash of the account data.</details></td></tr>
<tr><td><code>incr_nonce</code></td><td><code>[value]</code></td><td><code>[]</code></td><td>account</td><td><details><summary>View</summary>Increments the account nonce by the provided value. value is the value to increment the nonce by. value can be at most 2^32 - 1 otherwise this procedure panics.</details></td></tr>
<tr><td><code>get_item</code></td><td><code>[index]</code></td><td><code>[VALUE]</code></td><td>account, note</td><td><details><summary>View</summary>Gets an item from the account storage. Panics if the index is out of bounds. index is the index of the item to get. VALUE is the value of the item.</details></td></tr>
<tr><td><code>set_item</code></td><td><code>[index, V']</code></td><td><code>[R', V]</code></td><td>account</td><td><details><summary>View</summary>Sets an item in the account storage. Panics if the index is out of bounds. index is the index of the item to set. V' is the value to set. V is the previous value of the item. R' is the new storage root.</details></td></tr>
<tr><td><code>set_code</code></td><td><code>[CODE_ROOT]</code></td><td><code>[]</code></td><td>account</td><td><details><summary>View</summary>Sets the code of the account the transaction is being executed against. This procedure can only be executed on regular accounts with updatable code. Otherwise, this procedure fails. CODE_ROOT is the hash of the code to set.</details></td></tr>
<tr><td><code>get_balance</code></td><td><code>[faucet_id]</code></td><td><code>[balance]</code></td><td>account, note</td><td><details><summary>View</summary>Returns the balance of a fungible asset associated with a faucet_id. Panics if the asset is not a fungible asset. faucet_id is the faucet id of the fungible asset of interest. balance is the vault balance of the fungible asset.</details></td></tr>
<tr><td><code>has_non_fungible_asset</code></td><td><code>[ASSET]</code></td><td><code>[has_asset]</code></td><td>account, note</td><td><details><summary>View</summary>Returns a boolean indicating whether the non-fungible asset is present in the vault. Panics if the ASSET is a fungible asset. ASSET is the non-fungible asset of interest. has_asset is a boolean indicating whether the account vault has the asset of interest.</details></td></tr>
<tr><td><code>add_asset</code></td><td><code>[ASSET]</code></td><td><code>[ASSET']</code></td><td>account</td><td><details><summary>View</summary>Add the specified asset to the vault. Panics under various conditions. ASSET' final asset in the account vault defined as follows: If ASSET is a non-fungible asset, then ASSET' is the same as ASSET. If ASSET is a fungible asset, then ASSET' is the total fungible asset in the account vault after ASSET was added to it.</details></td></tr>
<tr><td><code>remove_asset</code></td><td><code>[ASSET]</code></td><td><code>[ASSET]</code></td><td>account</td><td><details><summary>View</summary>Remove the specified asset from the vault. Panics under various conditions. ASSET is the asset to remove from the vault.</details></td></tr>
<tr><td><code>get_vault_commitment</code></td><td><code>[]</code></td><td><code>[COM]</code></td><td>account, note</td><td><details><summary>View</summary>Returns a commitment to the account vault. COM is a commitment to the account vault.</details></td></tr>
</tbody></table>
</div>
<h3 id="note"><a class="header" href="#note">Note</a></h3>
<p>To import the note procedures set <code>use.miden::note</code> at the beginning of the file. All procedures are restricted to the note context.</p>
<div class="table-wrapper"><table><thead><tr><th>Procedure name</th><th>Inputs</th><th>Outputs</th><th>Context</th><th>Description</th></tr></thead><tbody>
<tr><td><code>get_assets</code></td><td><code>[dest_ptr]</code></td><td><code>[num_assets, dest_ptr]</code></td><td>note</td><td><details><summary>View</summary>Writes the assets of the currently executing note into memory starting at the specified address. dest_ptr is the memory address to write the assets. num_assets is the number of assets in the currently executing note.</details></td></tr>
<tr><td><code>get_inputs</code></td><td><code>[dest_ptr]</code></td><td><code>[dest_ptr]</code></td><td>note</td><td><details><summary>View</summary>Writes the inputs of the currently executed note into memory starting at the specified address. dest_ptr is the memory address to write the inputs.</details></td></tr>
<tr><td><code>get_sender</code></td><td><code>[]</code></td><td><code>[sender]</code></td><td>note</td><td><details><summary>View</summary>Returns the sender of the note currently being processed. Panics if a note is not being processed. sender is the sender of the note currently being processed.</details></td></tr>
</tbody></table>
</div>
<h3 id="tx"><a class="header" href="#tx">Tx</a></h3>
<p>To import the transaction procedures set <code>use.miden::tx</code> at the beginning of the file. Only the <code>create_note</code> procedure is restricted to the account context.</p>
<div class="table-wrapper"><table><thead><tr><th>Procedure name</th><th>Inputs</th><th>Outputs</th><th>Context</th><th>Description</th></tr></thead><tbody>
<tr><td><code>get_block_number</code></td><td><code>[]</code></td><td><code>[num]</code></td><td>account, note</td><td><details><summary>View</summary>Returns the block number of the last known block at the time of transaction execution. num is the last known block number.</details></td></tr>
<tr><td><code>get_block_hash</code></td><td><code>[]</code></td><td><code>[H]</code></td><td>account, note</td><td><details><summary>View</summary>Returns the block hash of the last known block at the time of transaction execution. H is the last known block hash.</details></td></tr>
<tr><td><code>get_input_notes_hash</code></td><td><code>[]</code></td><td><code>[COM]</code></td><td>account, note</td><td><details><summary>View</summary>Returns the input notes hash. This is computed as a sequential hash of (nullifier, script_root) tuples over all input notes. COM is the input notes hash.</details></td></tr>
<tr><td><code>get_output_notes_hash</code></td><td><code>[0, 0, 0, 0]</code></td><td><code>[COM]</code></td><td>account, note</td><td><details><summary>View</summary>Returns the output notes hash. This is computed as a sequential hash of (note_hash, note_metadata) tuples over all output notes. COM is the output notes hash.</details></td></tr>
<tr><td><code>create_note</code></td><td><code>[ASSET, tag, RECIPIENT]</code></td><td><code>[ptr]</code></td><td>account</td><td><details><summary>View</summary>Creates a new note and returns a pointer to the memory address at which the note is stored. ASSET is the asset to be included in the note. tag is the tag to be included in the note. RECIPIENT is the recipient of the note. ptr is the pointer to the memory address at which the note is stored.</details></td></tr>
</tbody></table>
</div>
<h3 id="asset"><a class="header" href="#asset">Asset</a></h3>
<p>To import the asset procedures set <code>use.miden::asset</code> at the beginning of the file. These procedures can only be called by faucet accounts.</p>
<div class="table-wrapper"><table><thead><tr><th>Procedure name</th><th>Stack</th><th>Output</th><th>Context</th><th>Description</th></tr></thead><tbody>
<tr><td><code>build_fungible_asset</code></td><td><code>[faucet_id, amount]</code></td><td><code>[ASSET]</code></td><td>faucet</td><td><details><summary>View</summary>Builds a fungible asset for the specified fungible faucet and amount. faucet_id is the faucet to create the asset for. amount is the amount of the asset to create. ASSET is the built fungible asset.</details></td></tr>
<tr><td><code>create_fungible_asset</code></td><td><code>[amount]</code></td><td><code>[ASSET]</code></td><td>faucet</td><td><details><summary>View</summary>Creates a fungible asset for the faucet the transaction is being executed against. amount is the amount of the asset to create. ASSET is the created fungible asset.</details></td></tr>
<tr><td><code>build_non_fungible_asset</code></td><td><code>[faucet_id, DATA_HASH]</code></td><td><code>[ASSET]</code></td><td>faucet</td><td><details><summary>View</summary>Builds a non-fungible asset for the specified non-fungible faucet and DATA_HASH. faucet_id is the faucet to create the asset for. DATA_HASH is the data hash of the non-fungible asset to build. ASSET is the built non-fungible asset.</details></td></tr>
<tr><td><code>create_non_fungible_asset</code></td><td><code>[DATA_HASH]</code></td><td><code>[ASSET]</code></td><td>faucet</td><td><details><summary>View</summary>Creates a non-fungible asset for the faucet the transaction is being executed against. DATA_HASH is the data hash of the non-fungible asset to create. ASSET is the created non-fungible asset.</details></td></tr>
</tbody></table>
</div>
<h3 id="faucet"><a class="header" href="#faucet">Faucet</a></h3>
<p>To import the faucet procedures set <code>use.miden::faucet</code> at the beginning of the file.</p>
<div class="table-wrapper"><table><thead><tr><th>Procedure name</th><th>Stack</th><th>Outputs</th><th>Context</th><th>Description</th></tr></thead><tbody>
<tr><td><code>mint</code></td><td><code>[ASSET]</code></td><td><code>[ASSET]</code></td><td>faucet</td><td><details><summary>View</summary>Mint an asset from the faucet the transaction is being executed against. Panics under various conditions. ASSET is the asset that was minted.</details></td></tr>
<tr><td><code>burn</code></td><td><code>[ASSET]</code></td><td><code>[ASSET]</code></td><td>faucet</td><td><details><summary>View</summary>Burn an asset from the faucet the transaction is being executed against. Panics under various conditions. ASSET is the asset that was burned.</details></td></tr>
<tr><td><code>get_total_issuance</code></td><td><code>[]</code></td><td><code>[total_issuance]</code></td><td>faucet</td><td><details><summary>View</summary>Returns the total issuance of the fungible faucet the transaction is being executed against. Panics if the transaction is not being executed against a fungible faucet. total_issuance is the total issuance of the fungible faucet the transaction is being executed against.</details></td></tr>
</tbody></table>
</div>
<h2 id="kernel-procedures"><a class="header" href="#kernel-procedures">Kernel Procedures</a></h2>
<p>WIP - we will add those later. </p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="transaction-modes"><a class="header" href="#transaction-modes">Transaction Modes</a></h2>
<p>There are two types of transactions in Miden: local transactions and network transactions.</p>
<p align="center">
    <img src="transactions/../diagrams/architecture/transaction/Local_vs_Network_Transaction.png">
</p>
<p>For <strong>local transactions</strong>, clients executing the transactions also generate the proofs of their correct execution. So, no additional work needs to be performed by the network. Local transactions are useful for several reasons:</p>
<ol>
<li>They are cheaper (i.e., lower fees) as ZKPs are already generated by the clients.</li>
<li>They allow fairly complex computations because the proof size doesn't grow linearly with the complexity of the computation.</li>
<li>They enable privacy as neither the account state nor account code are needed to verify the ZKP.</li>
</ol>
<p>For <strong>network transactions</strong>, the operator will execute the transaction and generate the proofs. Network transactions are useful for two reasons:</p>
<ol>
<li>Clients may not have sufficient resources to generate ZK proofs.</li>
<li>Executing many transactions against the same public account by different clients would be challenging as the account state would change after every transaction. In this case, the Miden Node / Operator acts as a &quot;synchronizer&quot; as they can execute transactions sequentially and feed the output of the previous transaction into the subsequent one.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="state"><a class="header" href="#state">State</a></h1>
<p>The state of the Miden rollup describes the current condition of all accounts and note states. It describes what is currently the case. With its state model, using concurrent off-chain state, Polygon Miden aims to realise private, and parallel transaction execution and state bloat minimization. Midens aims to realise:</p>
<ul>
<li><strong>Notes and nullifiers</strong> ensure privacy of note consumption</li>
<li><strong>Flexible data storage</strong> for users who can store their data off-chain or with the network</li>
<li><strong>Parallel transactions</strong> executed concurrently by distinct actors</li>
<li><strong>Concurrent state model</strong> allows block production without knowing the full state</li>
</ul>
<p>Privacy is realised from a UTXO-like state model consisting of notes and nullifiers combined with off-chain execution using zero-knowledge proofs. State bloat describes the ever growing state stored in blockchain nodes. Polygon Miden addresses this challenges via its state model that enables concurrent off-chain execution and off-chain storage. Simply put, in Miden users can store their own data locally which reduces the burden on the network - integrity is ensured using zero-knowledge.</p>
<h2 id="state-components"><a class="header" href="#state-components">State components</a></h2>
<p>The Miden Node(s) maintain three databases to describe the state:</p>
<ol>
<li>A database of accounts.</li>
<li>A database of notes.</li>
<li>A database of nullifiers for already consumed notes.</li>
</ol>
<p align="center">
  <img src="architecture/../diagrams/architecture/state/State.png" width="80%">
</p>
<p>These databases are represented by authenticated data structures, such that we can easily prove that items were added to or removed from a database, and a commitment to the database would be very small.</p>
<p>Polygon Miden has two databases to capture the note states. The note database is append-only and stores all notes permanently. The nullifier database stores nullifiers that indicate that a note has been previsously consumed. Separating note storage into these two databases gives Polygon Miden client-side proving and advanced privacy.</p>
<h3 id="account-database"><a class="header" href="#account-database">Account database</a></h3>
<p>The latest account states - and data for onchain accounts - are recorded in a [sparse Merkle tree] which maps account IDs to account hashes and account data if needed.</p>
<p align="center">
  <img src="architecture/../diagrams/architecture/state/Account_DB.png" width="80%">
</p>
<p>As described in <a href="https://0xpolygonmiden.github.io/miden-base/architecture/accounts.html#account-storage-modes">Accounts</a>, there are two types of accounts:</p>
<ul>
<li><strong>Public accounts</strong> where all account data is stored onchain.</li>
<li><strong>Private accounts</strong> where only the hashes of accounts are stored onchain.</li>
</ul>
<p>Private accounts significantly reduce the storage overhead for nodes. A private account contributes only <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">40</span></span></span></span> bytes to the global state (<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span> bytes account ID + <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> bytes account hash). Or, said another way, 1 billion private accounts takes up only <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">40</span></span></span></span> GB of state.</p>
<blockquote>
<p>Losing the state of a private account would mean loss of funds (as the user won't be able to execute transactions) in a similar manner as a loss of a private key would. This problem can be easily mitigated by storing encrypted account state in a cloud or backing it up somewhere else. Unlike storing private keys in the cloud, this does not compromise privacy or security of an account.</p>
</blockquote>
<p>In the future we also want to enable <strong>Encrypted accounts</strong> where the account data is stored onchain but in an encrypted format. This is especially interesting for shared accounts like advanced multi-sig wallets.</p>
<h3 id="note-database"><a class="header" href="#note-database">Note database</a></h3>
<p>Notes are recorded in an append-only accumulator, a <a href="https://github.com/opentimestamps/opentimestamps-server/blob/master/doc/merkle-mountain-range.md">Merkle Mountain Range</a>. Each leaf is a block header which contains the commitment to all notes created in that block. The commitment is a sparse Merkle tree of all the notes in a block. The size of the Merkle Mountain Range grows logarithmically with the number of items in it.</p>
<p align="center">
  <img src="architecture/../diagrams/architecture/state/Note_DB.png" width="80%">
</p>
<p>As described in <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-storage-modes">Notes</a>, there are two types of <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html">notes</a>:</p>
<ul>
<li><strong>Public notes</strong> where the entire note content is recorded in the state.</li>
<li><strong>Private notes</strong> where only a note's hash is recorded in the state.</li>
</ul>
<p>As with accounts, there is a strong incentive to use private notes as they result in lower fees. This is also beneficial to the network as a private note adds only <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span></span></span></span> bytes to the state (<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> bytes when it is produced, and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> bytes when it is consumed).</p>
<p>Using a Merkle Mountain Range (append-only accumulator) is important for two reasons:</p>
<ol>
<li>Membership witnesses (a note exists in the database) against such an accumulator needs to be updated very infrequently.</li>
<li>Old membership witnesses can be extended to be used with a new accumulator value, but this extension does not need to be done by the original witness holder.</li>
</ol>
<p>Both of these properties are needed for supporting local transactions using client-side proofs and privacy. In an append-only data structure, this witness data does not become stale when the data structure is updated. That means users can generate valid proofs even if they don’t have the latest state of this database, so there is no need to query the operator on a constantly changing state.</p>
<p>However, the size of the note database does not grow indefinitely. Theoretically, at high tps, it would grow very quickly: at <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>K TPS there would be about <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>TB/year added to the database. But, only the unconsumed public notes and enough info to construct membership proofs against them need to be stored explicitly. Private notes, as well as public notes which have already been consumed, can be safely discarded. Such notes would still remain in the accumulator, but there is no need to store them explicitly as the append-only accumulator can be updated without knowing all items stored in it. This reduces actual storage requirements to a fraction of the database's nominal size.</p>
<h3 id="nullifier-database"><a class="header" href="#nullifier-database">Nullifier database</a></h3>
<p>Nullifiers are stored in a <a href="https://0xpolygonmiden.github.io/miden-base/crypto-primitives/tsmt.html">Tiered Sparse Merkle Tree</a>, which maps <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-nullifier">Note Nullifiers</a> to <code>0</code> or <code>1</code>. Nullifiers provide information on whether a specific note has been consumed yet. The database allows proving that a given nullifier is not in the database.</p>
<p align="center">
  <img src="architecture/../diagrams/architecture/state/Nullifier_DB.png">
</p>
<p>To prove that a note has not been consumed previously, the operator needs to provide a Merkle path to its node, and then show that the value in that node is <code>0</code>. In our case nullifiers are <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> bytes each, and thus, the height of the Sparse Merkle tree need to be <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span>.</p>
<p>To be able to add new nullifiers to the database, operators needs to maintain the entire nullifier set. Otherwise, they would not be able to compute the new root of the tree.</p>
<p>*Note: Nullifiers as constructed in Miden break linkability of privately stored notes and the information about the note's consumption. To know the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-nullifier">note's nullifier</a> one must know the note's data.</p>
<p>In the future, when the network experiences a large number of transactions per second (TPS), there will be one tree per epoch (~3 months), and Miden nodes always store trees for at least two epochs. However, the roots of the old trees are still stored. If a user wants to consume a note that is more than <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span> month old, there must be a merkle path provided to the Miden Node for verification.</p>
<h2 id="state-bloat-minimization"><a class="header" href="#state-bloat-minimization">State bloat minimization</a></h2>
<p>Operators don’t need to know the entire state to verify or produce a new block. No operator is required to store the entire state.</p>
<p>At its core, the idea is simple: Instead of storing the full state data with the operators, the users store their data, and the rollup only keeps track of commitments to the data. At least for private accounts, some smart contracts need to be publicly visible. This minimizes state bloat—as the operator doesn’t need to store an ever-growing database—and provides privacy because all other users and the operator only see a hash of other users’ data.</p>
<p>That way the account and note databases can remain manageable, even at high usage for extended periods of time.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="execution-model-1"><a class="header" href="#execution-model-1">Execution Model</a></h1>
<p>Polygon Miden is an Ethereum Rollup. It batches transactions - or more precisely, proofs thereof - that happen together in the same time period into a block. The Execution Model describes how the state progresses on <strong>an individual level via transactions</strong> and <strong>at the global level expressed as aggregated state updates in blocks</strong>.</p>
<p align="center">
  <img src="architecture/../diagrams/architecture/execution/Execution.png">
</p>
<h2 id="transaction-execution-1"><a class="header" href="#transaction-execution-1">Transaction Execution</a></h2>
<p>Every transaction will result in a ZK proof that attests to its correctness.</p>
<p>As mentioned in <a href="https://0xpolygonmiden.github.io/miden-base/architecture/transactions.html#local-vs-network-transactions">transactions</a>, there are two types of transactions: local and network. For every transaction there is a proof which is either created by the user in the Miden Client or by the Operator using the Miden Node.</p>
<h2 id="transaction-batching"><a class="header" href="#transaction-batching">Transaction Batching</a></h2>
<p>To reduce the required space on the Ethereum blockchain, transaction proofs are aggregated into batches. This can happen in parallel by different machines that need to verify several proofs using the Miden VM and thus creating a proof. Verifying a STARK proof within the VM is relatively efficient but it is still a pretty costly operation (we aim for 2<sup>16</sup> cycles).</p>
<h2 id="block-production"><a class="header" href="#block-production">Block Production</a></h2>
<p>Several batch proofs are being aggregated together into one block. This can not happen in parallel and must be done by the Miden Operator running the Miden Node. The idea is the same, using recursive verification.</p>
<h2 id="state-progress"><a class="header" href="#state-progress">State progress</a></h2>
<p>At the beginning, Miden will have a centralized Operator running a Miden Node.</p>
<p>Users will send either transaction proofs (using local execution) or transaction data (for network execution) to the Miden Node. Later on, the Miden Node will use recursive verification to aggregate transaction proofs into batches.</p>
<p>Batch proofs are aggregated into blocks by the Miden Node. The blocks are then sent to Ethereum, and once a block is added to the L1 chain, the rollup chain is believed to have progressed to the next state.</p>
<p>A block produced by the Miden Node looks somewhat like this:</p>
<p align="center">
  <img src="architecture/../diagrams/architecture/execution/Block.png">
</p>
<ul>
<li><strong>state updates</strong> contain only the hashes of changes. For example, for each account which was updated, we record a tuple <code>([account id], [new account hash])</code>.</li>
<li>The included <strong>zk proof</strong> attests that given a state commitment from the previous block, there was a sequence of valid transactions executed that resulted in the new state commitment, and also output included state updates.</li>
<li>The block also contains full account and note data for public accounts and notes. For example, if account <code>123</code> is a public account which was updated, in the <em>state updates</em> section we'd have a records for it as <code>(123, 0x456..)</code>. The full new state of this account (which should hash to <code>0x456..</code>) would be included in a separate section.</li>
</ul>
<p>To verify that a block describes a valid state transition, we do the following:</p>
<ol>
<li>Compute hashes of public account and note states.</li>
<li>Make sure these hashes match records in the <em>state updates</em> section.</li>
<li>Verify the included ZKP against the following public inputs:
<ul>
<li>State commitment from the previous block.</li>
<li>State commitment from the current block.</li>
<li>State updates from the current block.</li>
</ul>
</li>
</ol>
<p>The above can be performed by a verifier contract on Ethereum L1.</p>
<p>This structure has another nice property. It is very easy for a new node to sync up to the current state from genesis. The new node would need to do the following:</p>
<ol>
<li>Download only the first part of the blocks (i.e., without full account/note states) starting at the genesis up until the latest block.</li>
<li>Verify all ZKPs in the downloaded blocks. This will be super quick (exponentially faster than re-executing original transactions) and can also be done in parallel.</li>
<li>Download the current states of account, note, and nullifier databases.</li>
<li>Verify that the downloaded current state matches the state commitment in the latest block.</li>
</ol>
<p>Overall, state sync is dominated by the time needed to download the data.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="polygon-miden-network-wip"><a class="header" href="#polygon-miden-network-wip">Polygon Miden Network [WIP]</a></h1>
<p>Polygon Miden is a bi-directional token bridge and state machine. Miden Nodes act as operators that keep the state and compress state transitions recursively into STARK-proofs. The token bridge on Ethereum verifies these proofs. Users can run Miden clients to send RPC requests to the Miden Nodes to update the state.</p>
<p>The major components of Polygon Miden are:</p>
<ul>
<li>Miden Clients - represent Miden users</li>
<li>Miden Nodes - manage the Miden rollup and compress proofs</li>
<li>Verifier Contract - keeps and verifies state on Ethereum</li>
<li>Bridge Contract - entry and exit point for users</li>
</ul>
<h2 id="network-slide"><a class="header" href="#network-slide">Network Slide</a></h2>
<p><img src="diagrams/network/Architecture_Overview.svg" alt="Miden Architecture Overview" /></p>
<h2 id="miden-clients"><a class="header" href="#miden-clients">Miden Clients</a></h2>
<p>Users will run Miden Clients. They are designed to provide an interface for wallets representing accounts on Miden. Miden Clients can execute and prove transactions in the Tx Prover. They can handle arbitrary signature schemes - whereas the default is Falcon. The wallet interface serves a user interface, a wallet database to be able to store account data locally, and the required smart contract code that represents the account on Miden.</p>
<p>Want to learn more about Miden Clients? See <a href="network/miden-clients.html">here</a>.</p>
<h2 id="miden-nodes"><a class="header" href="#miden-nodes">Miden Nodes</a></h2>
<p>Operators will run Miden Nodes. Operators ensure integrity of the Account, Note and Nullifier State - which represent the state of Polygon Miden. Operators can execute and proof transactions against single accounts and they can verify proofs of locally executed transactions. Furthermore, the operator compresses the proofs in several steps up to a single proofs that gets published and verified on the Verifier contract. Operators also watch events emitted by the Bridge Contract to detect deposits and withdrawals.</p>
<p>To manage all of this, Miden Nodes have different modules. The Node orchestrates a Tx Prover, a Tx Aggregator and a Block Producer. The Tx Prover executes and proves transactions, like in the Miden Client. The Tx Aggregator can batch multiple proofs together to reduce the final state proof size using recursive proving. The Block Producer exposes the RPC interface to the user. The Block Producer collects transactions in the Tx Pool and stores the state of Polygon Miden in its three databases (Accounts, Notes, Nullifiers).</p>
<p>Want to learn more about Miden Nodes? See <a href="network/miden-node.html">here</a>.</p>
<h2 id="verifier-contract"><a class="header" href="#verifier-contract">Verifier Contract</a></h2>
<p>This contract on Ethereum verifies proofs sent by the operator running a Miden Node. The proof is verified against the current state root. If accepted the state root changes.</p>
<p>Want to learn more about Miden Nodes? See <a href="network/verifier-contract.html">here</a>.</p>
<p>[This is a dummy text, we need to explain the contract in detail]</p>
<h2 id="bridge-contract"><a class="header" href="#bridge-contract">Bridge Contract</a></h2>
<p>This contract serves the Miden users on Ethereum as bridge. Users can deposit their tokens and get an equivalent amount minted and sent to the specified address on Polygon Miden.</p>
<p>Want to learn more about the bridge? See <a href="network/bridge.html">here</a>.</p>
<p>[This is a dummy text, we need to explain the contract in detail]</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="miden-clients-1"><a class="header" href="#miden-clients-1">Miden Clients</a></h1>
<p>Users use Miden Clients to interact in the network. The backend of any wallet that is used in Miden will be a Miden Client. Miden Clients consist of several components.</p>
<ul>
<li>Transaction Prover</li>
<li>Signature module</li>
<li>Wallet interface</li>
<li>Wallet database</li>
</ul>
<p>[We need a diagram to show the Miden Client]</p>
<h2 id="transaction-prover"><a class="header" href="#transaction-prover">Transaction Prover</a></h2>
<p>The Transaction Prover is able to execute transactions and create transaction execution proofs. It runs a Transaction Kernel at its heart.</p>
<h2 id="signature-module"><a class="header" href="#signature-module">Signature module</a></h2>
<p>[Unclear if this is a separate module]</p>
<h2 id="wallet-interface"><a class="header" href="#wallet-interface">Wallet interface</a></h2>
<p>At the beginning we only have a basic wallet interface which we implement for the testnet. It is rather simplistic.</p>
<p>The interface defines three methods:</p>
<pre><code>receive_asset
send_asset
auth_tx
</code></pre>
<p>The first two of the above methods should probably be an interface on their own, and we should recommend that most accounts implement these methods.</p>
<p>The goal is to provide a wallet with the following capabilities:</p>
<p>The wallet is controlled by a single key. The signature scheme is assumed to be Falcon. However, sending assets to the wallet does not require knowing which signature scheme is used by the recipient. The user can send, receive, and exchange assets stored in the wallet with other users. All operations (including receiving assets) must be authenticated by the account owner.</p>
<p>Interface method description
Below, we provide high-level details about each of the interface methods.</p>
<h3 id="receive_asset-method"><a class="header" href="#receive_asset-method"><code>receive_asset method</code></a></h3>
<p>The purpose of this method is to add a single asset to an account's vault. Pseudo-code for this method could look like so:</p>
<pre><code>receive_asset(asset)
    self.add_asset(asset)
end
</code></pre>
<p>In the above, <code>add_asset</code> is a kernel procedure <code>miden::account::add_asset</code> of the Tx Kernel.</p>
<p>Note: this method does not increment account nonce. The nonce will be incremented in auth_tx method described below. Thus, receiving assets requires authentication.</p>
<h3 id="send_asset-method"><a class="header" href="#send_asset-method"><code>send_asset method</code></a></h3>
<p>The purpose of this method is to create a note which sends a single asset to the specified recipient. Pseudo-code for this method could look like so:</p>
<pre><code>send_asset(asset, recipient)
    self.remove_asset(asset)
    tx.create_note(recipient, asset)
end
</code></pre>
<p>In the above, <code>remove_asset</code> is a kernel procedure <code>miden::account::remove_asset</code> and <code>create_note</code> is a kernel procedure <code>miden::tx::create_note</code>, both in the Tx Kernel.</p>
<p><code>recipient</code> is a partial hash of the created note computed outside the VM as <code>hash(hash(hash(serial_num), script_hash), input_hash)</code>. This allows computing note hash as <code>hash(recipient, vault_hash)</code> where the <code>vault_hash</code> can be computed inside the VM based on the specified asset.</p>
<p>Note: this method also does not increment account nonce. The nonce will be incremented in auth_tx method described below. Thus, sending assets requires authentication.</p>
<h3 id="auth_tx-method"><a class="header" href="#auth_tx-method"><code>auth_tx method</code></a></h3>
<p>The purpose of this method is to authenticate a transaction. For the purposes of this method we make the following assumptions:</p>
<p>Public key of the account is stored in account storage at index 0.
To authenticate a transaction we sign <code>hash(account_id || account_nonce || input_note_hash || output_note_hash)</code> using Falcon signature scheme. Pseudo-code for this method could look like so:</p>
<pre><code>auth_tx()
    # compute the message to sign
    let account_id = self.get_id()
    let account_nonce = self.get_nonce()
    let input_notes_hash = tx.get_input_notes_hash()
    let output_notes_hash = tx.get_output_notes_hash()
    let m = hash(account_id, account_nonce, input_notes_hash, output_notes_hash)

    # get public key from account storage and verify signature
    let pub_key = self.get_item(0)
    falcon::verify_sig(pub_key, m)

    # increment account nonce
    self.increment_nonce()
end
</code></pre>
<p>It is assumed that the signature for <code>falcon::verify_sig procedure</code> will be provided non-deterministically via the advice provider. Thus, the above procedure can succeed only if the prover has a valid Falcon signature over <code>hash(account_id || account_nonce || input_note_hash || output_note_hash)</code> for the public key stored in the account.</p>
<p>All procedures invoked as a part of this method, except for <code>falcon::verify_sig</code> have equivalent kernel procedures defined in the Tx Kernel. We assume that <code>falcon::verify_sig</code> is a part of Miden standard library.</p>
<h2 id="wallet-database"><a class="header" href="#wallet-database">Wallet database</a></h2>
<p>[Unclear yet how this database looks like. It should at least have <code>assets/vault</code>, <code>code</code>, <code>nonce</code>, <code>storage</code>]</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="miden-node"><a class="header" href="#miden-node">Miden node</a></h1>
<p>The Miden node is the software that processes transactions and creates blocks for the Miden rollup. It manages the network state and orchestrates three different modules.</p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>The Miden node is still under heavy development and the project can be considered to be in an <em>alpha</em> stage. Many features are yet to be implemented and there is a number of limitations which we will lift in the near future.</p>
<p>At this point, we are developing the Miden node for a centralized operator. Thus, the work does not yet include such components as P2P networking and consensus. These will also be added in the future.</p>
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<p>The Miden node is made up of three main components, which communicate over gRPC:</p>
<ul>
<li><strong><a href="network/../miden-node/miden-node-rpc.html">RPC</a>:</strong> an externally-facing component through which clients can interact with the node. It receives client requests (e.g., to synchronize with the latest state of the chain, or to submit transactions), performs basic validation, and forwards the requests to the appropriate internal components.</li>
<li><strong><a href="network/../miden-node/miden-node-store.html">Store</a>:</strong> maintains the state of the chain. It serves as the &quot;source of truth&quot; for the chain - i.e., if it is not in the store, the node does not consider it to be part of the chain.</li>
<li><strong><a href="network/../miden-node/miden-node-block-producer.html">Block Producer</a>:</strong> accepts transactions from the RPC component, creates blocks containing those transactions, and sends them to the store.</li>
</ul>
<p>All three components can either run as one process, or each component can run in its own process.</p>
<p>The diagram below illustrates high-level design of each component as well as basic interactions between them (components in light-grey are yet to be built).</p>
<p><img src="network/../diagrams/network/Miden_node.png" alt="Architecture diagram" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="miden-node-rpc"><a class="header" href="#miden-node-rpc">Miden node RPC</a></h1>
<p>The <strong>RPC</strong> is an externally-facing component through which clients can interact with the node. It receives client requests (e.g., to synchronize with the latest state of the chain, or to submit transactions), performs basic validation, 
and forwards the requests to the appropriate components.</p>
<p><strong>RPC</strong> is one of components of the Miden node.</p>
<h2 id="architecture-2"><a class="header" href="#architecture-2">Architecture</a></h2>
<p><code>TODO</code></p>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<p>The <strong>RPC</strong> serves connections using the <a href="https://grpc.io">gRPC protocol</a> on a port, set in the previously mentioned configuration file. 
Here is a brief description of supported methods.</p>
<h3 id="checknullifiers"><a class="header" href="#checknullifiers">CheckNullifiers</a></h3>
<p>Gets a list of proofs for given nullifier hashes, each proof as Tiered Sparse Merkle Trees (<a href="https://github.com/0xPolygonMiden/miden-node/blob/main/proto/proto/tsmt.proto">read more</a>). </p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>nullifiers</code>: <code>[Digest]</code> – array of nullifier hashes.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>proofs</code>: <code>[NullifierProof]</code> – array of nullifier proofs, positions correspond to the ones in request.</li>
</ul>
<h3 id="getblockheaderbynumber"><a class="header" href="#getblockheaderbynumber">GetBlockHeaderByNumber</a></h3>
<p>Retrieves block header by given block number.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>block_num</code>: <code>uint32</code> <em>(optional)</em> – the block number of the target block. If not provided, the latest known block will be returned.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>block_header</code>: <code>BlockHeader</code> – block header.</li>
</ul>
<h3 id="syncstate"><a class="header" href="#syncstate">SyncState</a></h3>
<p>Returns info which can be used by the client to sync up to the latest state of the chain
for the objects (accounts, notes, nullifiers) the client is interested in.</p>
<p>This request returns the next block containing requested data. It also returns <code>chain_tip</code> which is the latest block number in the chain. 
Client is expected to repeat these requests in a loop until <code>response.block_header.block_num == response.chain_tip</code>, at which point the client is fully synchronized with the chain.</p>
<p>Each request also returns info about new notes, nullifiers etc. created. It also returns Chain MMR delta that can be used to update the state of Chain MMR. 
This includes both chain MMR peaks and chain MMR nodes.</p>
<p>For preserving some degree of privacy, note tags and nullifiers filters contain only high part of hashes. Thus, returned data
contains excessive notes and nullifiers, client can make additional filtering of that data on its side.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>block_num</code>: <code>uint32</code> – send updates to the client starting at this block.</li>
<li><code>account_ids</code>: <code>[AccountId]</code> – accounts filter.</li>
<li><code>note_tags</code>: <code>[uint32]</code> – note tags filter. Corresponds to the high 16 bits of the real values. </li>
<li><code>nullifiers</code>: <code>[uint32]</code> – nullifiers filter. Corresponds to the high 16 bits of the real values.</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><code>chain_tip</code>: <code>uint32</code> – number of the latest block in the chain.</li>
<li><code>block_header</code>: <code>BlockHeader</code> – block header of the block with the first note matching the specified criteria.</li>
<li><code>mmr_delta</code>: <code>MmrDelta</code> – data needed to update the partial MMR from <code>block_num</code> to <code>block_header.block_num</code>.</li>
<li><code>block_path</code>: <code>MerklePath</code> – Merkle path in the updated chain MMR to the block at <code>block_header.block_num</code>.</li>
<li><code>accounts</code>: <code>[AccountHashUpdate]</code> – a list of account hashes updated after <code>block_num</code> but not after <code>block_header.block_num</code>.</li>
<li><code>notes</code>: <code>[NoteSyncRecord]</code> – a list of all notes together with the Merkle paths from <code>block_header.note_root</code>.</li>
<li><code>nullifiers</code>: <code>[NullifierUpdate]</code> – a list of nullifiers created between <code>block_num</code> and <code>block_header.block_num</code>.</li>
</ul>
<h3 id="submitproventransaction"><a class="header" href="#submitproventransaction">SubmitProvenTransaction</a></h3>
<p>Submits proven transaction to the Miden network.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>transaction</code>: <code>bytes</code> - transaction encoded using Miden's native format.</li>
</ul>
<p><strong>Returns</strong></p>
<p>This method doesn't return any data.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="miden-node-store"><a class="header" href="#miden-node-store">Miden node store</a></h1>
<p>The <strong>Store</strong> maintains the state of the chain. It serves as the &quot;source of truth&quot; for the chain - i.e., if it is not in 
the store, the node does not consider it to be part of the chain. 
<strong>Store</strong> is one of components of the Miden node.</p>
<h2 id="architecture-3"><a class="header" href="#architecture-3">Architecture</a></h2>
<p><code>TODO</code></p>
<h2 id="api-1"><a class="header" href="#api-1">API</a></h2>
<p>The <strong>Store</strong> serves connections using the <a href="https://grpc.io">gRPC protocol</a> on a port, set in the previously mentioned configuration file. The API cannot directly be called by the Miden Client.</p>
<p>Here is a brief description of supported methods.</p>
<h3 id="applyblock"><a class="header" href="#applyblock">ApplyBlock</a></h3>
<p>Applies changes of a new block to the DB and in-memory data structures.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>block</code>: <code>BlockHeader</code> – block header (<a href="https://github.com/0xPolygonMiden/miden-node/blob/main/proto/proto/block_header.proto">src</a>).</li>
<li><code>accounts</code>: <code>[AccountUpdate]</code> – a list of account updates.</li>
<li><code>nullifiers</code>: <code>[Digest]</code> – a list of nullifier hashes.</li>
<li><code>notes</code>: <code>[NoteCreated]</code> – a list of notes created.</li>
</ul>
<p><strong>Returns</strong></p>
<p>This method doesn't return any data.</p>
<h3 id="checknullifiers-1"><a class="header" href="#checknullifiers-1">CheckNullifiers</a></h3>
<p>Get a list of proofs for given nullifier hashes, each proof as Tiered Sparse Merkle Trees (<a href="https://github.com/0xPolygonMiden/miden-node/blob/main/proto/proto/tsmt.proto">read more</a>).</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>nullifiers</code>: <code>[Digest]</code> – array of nullifier hashes.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>proofs</code>: <code>[NullifierProof]</code> – array of nullifier proofs, positions correspond to the ones in request.</li>
</ul>
<h3 id="getblockheaderbynumber-1"><a class="header" href="#getblockheaderbynumber-1">GetBlockHeaderByNumber</a></h3>
<p>Retrieves block header by given block number.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>block_num</code>: <code>uint32</code> <em>(optional)</em> – the block number of the target block. If not provided, the latest known block will be returned.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>block_header</code>: <code>BlockHeader</code> – block header.</li>
</ul>
<h3 id="getblockinputs"><a class="header" href="#getblockinputs">GetBlockInputs</a></h3>
<p>Returns data needed by the block producer to construct and prove the next block.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>account_ids</code>: <code>[AccountId]</code> – array of account IDs. </li>
<li><code>nullifiers</code>: <code>[Digest]</code> – array of nullifier hashes (not currently in use).</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><code>block_header</code>: <code>[BlockHeader]</code> – the latest block header.</li>
<li><code>mmr_peaks</code>: <code>[Digest]</code> – peaks of the above block's mmr, The <code>forest</code> value is equal to the block number.</li>
<li><code>account_states</code>: <code>[AccountBlockInputRecord]</code> – the hashes of the requested accounts and their authentication paths.</li>
<li><code>nullifiers</code>: <code>[NullifierBlockInputRecord]</code> – the requested nullifiers and their authentication paths.</li>
</ul>
<h3 id="gettransactioninputs"><a class="header" href="#gettransactioninputs">GetTransactionInputs</a></h3>
<p>Returns the data needed by the block producer to check validity of an incoming transaction. </p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>account_id</code>: <code>AccountId</code> – ID of the account against which a transaction is executed.</li>
<li><code>nullifiers</code>: <code>[Digest]</code> – array of nullifiers for all notes consumed by a transaction.</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><code>account_state</code>: <code>AccountTransactionInputRecord</code> – account's descriptors. </li>
<li><code>nullifiers</code>: <code>[NullifierTransactionInputRecord]</code> – the block numbers at which corresponding nullifiers have been consumed, zero if not consumed.</li>
</ul>
<h3 id="syncstate-1"><a class="header" href="#syncstate-1">SyncState</a></h3>
<p>Returns info which can be used by the client to sync up to the latest state of the chain
for the objects (accounts, notes, nullifiers) the client is interested in.</p>
<p>This request returns the next block containing requested data. It also returns <code>chain_tip</code> which is the latest block number in the chain.
Client is expected to repeat these requests in a loop until <code>response.block_header.block_num == response.chain_tip</code>, at which point the client is fully synchronized with the chain.</p>
<p>Each request also returns info about new notes, nullifiers etc. created. It also returns Chain MMR delta that can be used to update the state of Chain MMR.
This includes both chain MMR peaks and chain MMR nodes.</p>
<p>For preserving some degree of privacy, note tags and nullifiers filters contain only high part of hashes. Thus, returned data
contains excessive notes and nullifiers, client can make additional filtering of that data on its side.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>block_num</code>: <code>uint32</code> – send updates to the client starting at this block.</li>
<li><code>account_ids</code>: <code>[AccountId]</code> – accounts filter.</li>
<li><code>note_tags</code>: <code>[uint32]</code> – note tags filter. Corresponds to the high 16 bits of the real values.</li>
<li><code>nullifiers</code>: <code>[uint32]</code> – nullifiers filter. Corresponds to the high 16 bits of the real values.</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><code>chain_tip</code>: <code>uint32</code> – number of the latest block in the chain.</li>
<li><code>block_header</code>: <code>BlockHeader</code> – block header of the block with the first note matching the specified criteria.</li>
<li><code>mmr_delta</code>: <code>MmrDelta</code> – data needed to update the partial MMR from <code>block_num</code> to <code>block_header.block_num</code>.</li>
<li><code>block_path</code>: <code>MerklePath</code> – Merkle path in the updated chain MMR to the block at <code>block_header.block_num</code>.</li>
<li><code>accounts</code>: <code>[AccountHashUpdate]</code> – a list of account hashes updated after <code>block_num</code> but not after <code>block_header.block_num</code>.</li>
<li><code>notes</code>: <code>[NoteSyncRecord]</code> – a list of all notes together with the Merkle paths from <code>block_header.note_root</code>.</li>
<li><code>nullifiers</code>: <code>[NullifierUpdate]</code> – a list of nullifiers created between <code>block_num</code> and <code>block_header.block_num</code>.</li>
</ul>
<h2 id="methods-for-testing-purposes"><a class="header" href="#methods-for-testing-purposes">Methods for testing purposes</a></h2>
<h3 id="listnullifiers"><a class="header" href="#listnullifiers">ListNullifiers</a></h3>
<p>Lists all nullifiers of the current chain.</p>
<p><strong>Parameters</strong></p>
<p>This request doesn't have any parameters.</p>
<p><strong>Returns</strong></p>
<ul>
<li><code>nullifiers</code>: <code>[NullifierLeaf]</code> – lists of all nullifiers of the current chain. </li>
</ul>
<h3 id="listaccounts"><a class="header" href="#listaccounts">ListAccounts</a></h3>
<p>Lists all accounts of the current chain.</p>
<p><strong>Parameters</strong></p>
<p>This request doesn't have any parameters.</p>
<p><strong>Returns</strong></p>
<ul>
<li><code>accounts</code>: <code>[AccountInfo]</code> – list of all accounts of the current chain.</li>
</ul>
<h3 id="listnotes"><a class="header" href="#listnotes">ListNotes</a></h3>
<p>Lists all notes of the current chain.</p>
<p><strong>Parameters</strong></p>
<p>This request doesn't have any parameters.</p>
<p><strong>Returns</strong></p>
<ul>
<li><code>notes</code>: <code>[Note]</code> – list of all notes of the current chain.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="miden-block-producer"><a class="header" href="#miden-block-producer">Miden block producer</a></h1>
<p>The <strong>Block producer</strong> receives transactions from the RPC component, processes them, creates block containing those transactions before sending created blocks to the store. </p>
<p><strong>Block Producer</strong> is one of components of the Miden node. </p>
<h2 id="architecture-4"><a class="header" href="#architecture-4">Architecture</a></h2>
<p><code>TODO</code></p>
<h2 id="api-2"><a class="header" href="#api-2">API</a></h2>
<p>The <strong>Block Producer</strong> serves connections using the <a href="https://grpc.io">gRPC protocol</a> on a port, set in the previously mentioned configuration file. The API cannot directly be called by the Miden Client. </p>
<p>Here is a brief description of supported methods.</p>
<h3 id="submitproventransaction-1"><a class="header" href="#submitproventransaction-1">SubmitProvenTransaction</a></h3>
<p>Submits proven transaction to the Miden network.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><code>transaction</code>: <code>bytes</code> - transaction encoded using Miden's native format.</li>
</ul>
<p><strong>Returns</strong></p>
<p>This method doesn't return any data.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="verifier-contract-1"><a class="header" href="#verifier-contract-1">Verifier Contract</a></h1>
<p>[WIP]</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="bridge"><a class="header" href="#bridge">Bridge</a></h1>
<p>[WIP]</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p align="center">
    <img src="./diagrams/roadmap/miden_roadmap_dec_23.jpg">
</p><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="tiered-sparse-merkle-tree-tsmt"><a class="header" href="#tiered-sparse-merkle-tree-tsmt">Tiered Sparse Merkle Tree (TSMT)</a></h1>
<p>A sparse Merkle tree (SMT) is a cryptographic data structure that allows authenticated manipulations of a key-value store, i.e. a dictionary. It is a Merkle tree because it is
a binary tree in which each leaf node represents a key-value pair, and each non-leaf node represents the hash of the concatenation of its two child nodes. The index of the
leaf node in the tree corresponds to the key and the data stored in this node corresponds to the value. This implies that the depth of such a tree is logarithmic in the size of the key space, which implies that, for most key spaces used in practice, such a tree is impractical if done naively. However, the tree is sparse, i.e. it is going to be made up of mostly empty leaves, which in turn implies that most sub-trees are empty with roots that can be pre-computed.
A major issue with SMTs is the fact that operations scale with the size of the key space, meaning, for example, that if our key space has size <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mspace nobreak"> </span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">256</span></span></span></span></span></span></span></span></span></span></span></span>, then performing any operation on the key-value store, for example, an update, will require performing <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span> hashing operations. This is undesirable both inside as well as outside the STARK.</p>
<p>A common solution to this issue is to keep only non-empty leaves in the tree, which in practice means that sub-trees with only one non-empty child are replaced with the sub-tree rooted at that non-empty child. Here's an example of this:</p>
<p align="center">
    <img src="crypto-primitives/./diagram/../../diagrams/crypto-primitives/tsmt/tsmt_compaction_example.svg">
</p>
<p>Compaction implies then that the tree depth is logarithmic in the size of the dictionary entries as opposed to the size of the key space. This, in turn, means that the number of hashing required for executing operations on the key-value map scales logarithmically in the size of the map.</p>
<p>The first documented implementation of a compact SMT was described <a href="https://github.com/proofchains/python-proofmarshal/blob/master/proofmarshal/merbinnertree.py">here</a>. This implementation relies on augmenting nodes with
a field called <code>prefix</code> which is the longest common prefix of all childs of a given node. This means that internal nodes are hashes of a left and right child together with <code>prefix</code>, i.e. <code>(LEFT || RIGHT || PREFIX)</code>. Leaf nodes are hashes of just the key-value pair. In addition, domain separation is used to distinguish
between an internal and a leaf node by appending a <code>0</code> or <code>1</code> before hashing.
A disadvantage of this implementation, as well as all known implementations of compact SMTs, is the reliance of their operations on bit-wise manipulations. This makes them very expensive to implement inside Miden VM.</p>
<p>Tiered sparse Merkle trees (TSMT) are a result of the idea that one can trade hashing for more efficient bit-wise operations. More precisely, in TSMT, compaction happens only at certain pre-specified tiers and this leads to simpler bit-wise manipulations. In the case of Miden VM, compaction happens at depths <code>16</code>, <code>32</code>, <code>48</code> and <code>64</code>. To illustrate this, consider the following example where the keys have length 4, i.e. the SMT has depth 4.</p>
<p align="center">
    <img src="crypto-primitives/./diagram/../../diagrams/crypto-primitives/tsmt/tsmt_non_compact.svg">
</p>
<p>If we choose the tiers to be at depths 2 and 4 then the compact version of the above tree will look like</p>
<p align="center">
    <img src="crypto-primitives/./diagram/../../diagrams/crypto-primitives/tsmt/tsmt_compact_2.svg">
</p>
<p>If, however, we choose compaction at all possible depths we get a compact SMT that is similar to the <a href="https://developers.diem.com/papers/jellyfish-merkle-tree/2021-01-14.pdf">Jellyfish SMT</a></p>
<p align="center">
    <img src="crypto-primitives/./diagram/../../diagrams/crypto-primitives/tsmt/tsmt_compact_1.svg">
</p>
<p>We can see that a TSMT is a parametrized SMT, where the parameter is the number of tiers, that interpolates between a plain SMT with no compaction and a  (fully) compact SMT with compaction allowed at evey depth.</p>
<p>The Miden VM TSMT is a map from a key-space of size approximately <code>256</code>-bit to a value-space of the same size and are represented by four <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span></span></span></span>-bit field elements in the Miden VM native field, i.e. a <code>Word</code>. Athough keys are <code>256</code>-bit long the maximal tree depth that is allowed is <code>64</code>. This has several consequences:</p>
<ol>
<li>Limiting the tree depth to <code>64</code> means that we can use one of the four field elements making up the (full) key as the (compact) key in the TSMT. We choose the 4th field element to act as the (compact) key since when loading the (full) key on the operand stack, the 4th field element will be at the tip of the operand stack and thus will be easier to access. Using a single field element to act as the (compact) key implies that we can levarage the native instructions of the Miden VM to manipulate it during the course of operations on the TSMT inside the VM.</li>
<li>In order to deal with keys sharing a common prefix of length greater than <code>64</code>, we introduce a special type of leaf nodes at depth <code>64</code>. These leaf nodes are a sorted list of <code>(key, value)</code> pairs where sorting is done using <code>key</code>. Notice that all pairs in the sorted list have the same first part of the key, namely they share a common <code>64</code>-bit prefix , and that all pairs with the same first part of the key belong in the same sorted list. The decision to go with a sorted list of pairs instead of a standard sub-tree node with multiple childs at depth <code>80</code> sharing the same <code>64</code>-bit prefix is partially motivated by the fact that, for most scenarios related to Miden VM, the probability that two distinct keys will end up sharing a common prefix of length greater than or equal to <code>64</code> is very low, and even feasible grinding attacks can only make the sorted list on slightly longer than a dozen of elements and with very little clear benefits. Thus putting all pairs with the same first part of the key in a sorted list is a good tradeoff for dealing with prefixes of length greater than <code>64</code>.</li>
</ol>
<p>The Miden VM TSMT has three types of nodes:</p>
<ol>
<li>Internal nodes with a left and right child, and value computed as: <code>Hash(left || right)</code></li>
<li>Leaf nodes at depths <code>16</code>, <code>32</code> and <code>48</code> with value computed as: <code>Hash(rem_key || value; domain=depth)</code> where:
<ol>
<li><code>depth</code> is the depth of the node, i.e. either <code>16</code>, <code>32</code> or <code>48</code>.</li>
<li><code>rem_key</code> is the the remaining key after either the <code>16</code>, <code>32</code> or <code>48</code>-bit prefix is removed depending on the depth of the node.</li>
<li><code>domain</code> is a domain separation tag used to distinguish between internal and leaf nodes.</li>
</ol>
</li>
<li>Leaf nodes at depth <code>64</code> with values computed as: <code>Hash((rem_key_1, value_1) || ... || (rem_key_n, value_n); domain=64)</code> where:
<ol>
<li><code>rem_key_i</code> is the remaining key after the <code>64</code>-bit prefix is removed.</li>
<li><code>value_i</code> is the value associated with the key <code>key_i</code>.</li>
<li><code>rem_key_i</code> are sorted in increasing order.</li>
</ol>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
