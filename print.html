<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Polygon Miden Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/overview.html"><strong aria-hidden="true">1.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="introduction/getting-started.html"><strong aria-hidden="true">1.2.</strong> Getting started</a></li></ol></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">2.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/accounts.html"><strong aria-hidden="true">2.1.</strong> Accounts</a></li><li class="chapter-item expanded "><a href="architecture/notes.html"><strong aria-hidden="true">2.2.</strong> Notes</a></li><li class="chapter-item expanded "><a href="architecture/assets.html"><strong aria-hidden="true">2.3.</strong> Assets</a></li><li class="chapter-item expanded "><a href="architecture/transactions.html"><strong aria-hidden="true">2.4.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="architecture/state.html"><strong aria-hidden="true">2.5.</strong> State</a></li><li class="chapter-item expanded "><a href="architecture/execution.html"><strong aria-hidden="true">2.6.</strong> Execution</a></li></ol></li><li class="chapter-item expanded "><a href="network.html"><strong aria-hidden="true">3.</strong> Network</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="network/miden-clients.html"><strong aria-hidden="true">3.1.</strong> Miden Clients</a></li><li class="chapter-item expanded "><a href="network/miden-node.html"><strong aria-hidden="true">3.2.</strong> Miden Node</a></li><li class="chapter-item expanded "><a href="network/verifier-contract.html"><strong aria-hidden="true">3.3.</strong> Verifier Contract</a></li><li class="chapter-item expanded "><a href="network/bridge.html"><strong aria-hidden="true">3.4.</strong> Bridge</a></li></ol></li><li class="chapter-item expanded "><a href="developer-info.html"><strong aria-hidden="true">4.</strong> Developer info</a></li><li class="chapter-item expanded "><a href="specifications.html"><strong aria-hidden="true">5.</strong> Specifications</a></li><li class="chapter-item expanded "><a href="crypto-primitives.html"><strong aria-hidden="true">6.</strong> Cryptographic primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crypto-primitives/tsmt.html"><strong aria-hidden="true">6.1.</strong> Tiered Sparse Merkle Tree (TSMT)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Polygon Miden Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xPolygonMiden/miden-base/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="polygon-miden"><a class="header" href="#polygon-miden">Polygon Miden</a></h1>
<blockquote>
<p><em>This documentation is still Work In Progress. Some topics have been discussed in greater depth, while others require additional clarification. Sections of this documentation might later be reorganized in order to achieve a better flow.</em></p>
</blockquote>
<h2 id="welcome-to-the-polygon-miden-documentation"><a class="header" href="#welcome-to-the-polygon-miden-documentation">Welcome to the Polygon Miden Documentation</a></h2>
<p>Polygon Miden is a zkRollup for high-throughput and private applications. Anyone can create zero-knowledge proofs of their own state changes, and Miden only verifies. It is expected to launch a public testnet in Q4.</p>
<p>This documentation explains the Miden architecture and concepts, the network and its components, and the underlying cryptographic primitives.</p>
<p>Press <code>s</code> or for full-text search in the docs.</p>
<p>If you want to join the technical discussion, please check out</p>
<ul>
<li>the <a href="https://discord.gg/0xpolygondevs">Discord</a>,</li>
<li>the <a href="https://github.com/0xPolygonMiden">Repo</a>,</li>
<li>the roadmap goals</li>
</ul>
<h2 id="miden-creates-a-new-design-space-secured-by-ethereum"><a class="header" href="#miden-creates-a-new-design-space-secured-by-ethereum">Miden creates a new design space secured by Ethereum</a></h2>
<p>Our goal is to not only scale Ethereum but to extend it. Rollups - secured by Ethereum - can be new design spaces and even experimental. This is the place to innovate. The base layer, however, should stay conservative and only slowly evolve to ensure the required safety and stability.</p>
<p>Like other rollups, we want to scale Ethereum and inherit its security. We want to provide a safe and decentralized environment for composable smart contracts.</p>
<p>Unlike most other rollups, Polygon Miden prioritizes ZK-friendliness over EVM compatibility. It also uses a novel, actor-based state model to exploit the full power of a ZK-centric design. These design choices allow Polygon Miden to extend Ethereum’s feature set. These features allow developers to create applications currently infeasible on EVM-like systems.</p>
<h2 id="benefits-of-polygon-miden"><a class="header" href="#benefits-of-polygon-miden">Benefits of Polygon Miden</a></h2>
<ul>
<li>Ethereum security</li>
<li>Developers can build applications infeasible on other systems, e.g.
<ul>
<li><strong>onchain order book exchange</strong> due to parallel tx exectuion and updatable transactions</li>
<li><strong>complex, incomplete information games</strong> due to client-side proving and cheap complex computations</li>
<li><strong>safe wallets</strong> due to assets being stored in the accounts and account state can be (partially) hidden</li>
</ul>
</li>
<li>Better privacy properties than on Ethereum - first web2 privacy, later even stronger privacy guarantees</li>
<li>Transactions can be recalled and updated</li>
<li>Lower fees due to client-side proving</li>
<li>dApps on Miden are safe to use due to account abstraction and modern smart contract languages</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Polygon Miden, a ZK-optimized rollup with client-side proving, will complement Polygon’s set of zero-knowledge solutions aiming to become the internet's value layer.</p>
<p>Unlike many other rollups, Polygon Miden prioritizes ZK-friendliness over EVM compatibility. It also uses a novel state model to exploit the full power of a ZK-centric design. These design decisions allow developers to create applications that are currently difficult or impractical to build on account-based systems.</p>
<p>This documentation presents detailed guides on:</p>
<ul>
<li>Polygon Miden Architecture</li>
<li>Polygon Miden Network Design [WIP]</li>
<li>Participating in the Polygon Miden Testnet [WIP]</li>
</ul>
<p>The Polygon Miden <strong>Architecture</strong> describes Miden's unique state and execution model - an actor-based model with concurrent off-chain state.</p>
<p>From the <strong>Network Design</strong> perspective, Polygon Miden uses a bi-directional token bridge and verifier contract to ensure computational integrity [WIP]. Miden Nodes act as operators that keep the state and compress state transitions recursively into STARK-proofs. The token bridge on Ethereum verifies these proofs. Users can run Miden Clients to send RPC requests to the Miden Nodes to update the state.</p>
<p>Once we are ready, we will provide an in-depth guide on how developers can participate to use our <strong>testnet</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<blockquote>
<p>[WIP]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>The Polygon Miden Architecture decribes the concepts of how the participants of the network can interact.</p>
<p>The architecture reflects the design goals for the rollup:</p>
<ul>
<li><strong>High throughput</strong></li>
<li><strong>Privacy</strong></li>
<li><strong>Asset Safety</strong></li>
</ul>
<p>On Miden, developers can build dApps currently infeasible anywhere else.</p>
<h2 id="actor-model"><a class="header" href="#actor-model">Actor Model</a></h2>
<p>The <a href="https://en.wikipedia.org/wiki/Actor_model">Actor Model</a> inspires Miden to achieve concurrent and local state changes. Actors are little state machines with inboxes, meaning each actor is responsible for their state. Actors can send and receive messages to communicate with other actors. Messages can be read asynchronously.</p>
<h2 id="concepts-in-miden"><a class="header" href="#concepts-in-miden">Concepts in Miden</a></h2>
<p>There are accounts and notes which can hold assets. Accounts consume and produce notes in transactions. Transactions are account state changes of single accounts. The state model captures all individual states of all accounts and notes. Finally, the execution model describes state progress in a sequence of blocks.</p>
<h3 id="accounts"><a class="header" href="#accounts">Accounts</a></h3>
<p>Accounts can hold assets and define rules how those can be transferred. Accounts can represent users or autonomous smart contracts. This chapter describes the design, the storage types, and the creation of an account.</p>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<p>Notes are messages carrying assets that accounts can send to each other. A note stores assets and a script that defines how this note can be consumed. This chapter describes the design, the storage types, and the creation of a note.</p>
<h3 id="assets"><a class="header" href="#assets">Assets</a></h3>
<p>Assets can be fungible and non-fungible. They are stored in the owner’s account itself or in a note. This chapter describes asset issuance, customization, and storage.</p>
<h3 id="transactions"><a class="header" href="#transactions">Transactions</a></h3>
<p>Transactions describe production or consumption of notes by a single account. For every transaction there is always a STARK proof in Miden. This chapter describes the transaction design and the different transaction modes.</p>
<h3 id="state-model"><a class="header" href="#state-model">State Model</a></h3>
<p>State describes everything that is the case at a certain point in time. Individual state of accounts or notes can be stored onchain and offchain to provide privacy. This chapter describes the three different state databases in Miden.</p>
<h3 id="execution-model"><a class="header" href="#execution-model">Execution Model</a></h3>
<p>Execution describes how the state progresses - on an individual level via transactions and at the global level expressed as aggregated state updates in blocks. This chapter describes the execution model and how blocks are built.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="accounts-1"><a class="header" href="#accounts-1">Accounts</a></h1>
<p>Miden aims to support expressive smart contracts via a Turing-complete language. For smart contracts the go-to solution is account-based state. In Miden, an account is an entity which holds assets and defines rules of how these assets can be transferred. They are basic building blocks representing a user or an autonomous smart contract.</p>
<h2 id="account-design"><a class="header" href="#account-design">Account Design</a></h2>
<p>The diagram below illustrates basic components of an account. In Miden every account is a smart contract.</p>
<p align="center">
    <img src="architecture/../diagrams/architecture/account/Account_Definition.png">
</p>
<p>In the above picture, you can see:</p>
<ul>
<li><strong>Account ID →</strong> a unique identifier of an account which does not change throughout its lifetime</li>
<li><strong>Storage →</strong> a user-defined data which can be stored in an account</li>
<li><strong>Nonce →</strong> a counter which must be incremented whenever account state changes</li>
<li><strong>Vault →</strong> a collection of assets stored in an account</li>
<li><strong>Code →</strong> a collection of functions which define an external interface for an account</li>
</ul>
<h3 id="account-id"><a class="header" href="#account-id">Account ID</a></h3>
<p>~63 bits (1 Felt) long identifier for the account. The first three significant bits specify its type and the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/accounts.html#account-storage-modes">storage mode</a>. There are four types of accounts in Miden:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Regular updatable account</th><th>Regular immutable account</th><th>Faucet for fungible assets</th><th>Faucet for non-fungible assets</th></tr></thead><tbody>
<tr><td><strong>Description</strong></td><td>Will be used by most users for a wallet. Code specification and changes possible.</td><td>Will be used by most smart contracts. Once deployed code cannot be changed</td><td>Users can issue fungible assets and customize them.</td><td>Users can issue non-fungible assets and customize them.</td></tr>
<tr><td><strong>Code updatability</strong></td><td>yes</td><td>no</td><td>no</td><td>no</td></tr>
<tr><td><strong>Most significant bits</strong></td><td><code>00</code></td><td><code>01</code></td><td><code>10</code></td><td><code>11</code></td></tr>
</tbody></table>
</div>
<h4 id="example-account-id-big-endian"><a class="header" href="#example-account-id-big-endian">Example account ID (big-endian)</a></h4>
<p align="center">
    <img src="architecture/../diagrams/architecture/account/Account_ID.png">
</p>
<p><em>Note: Miden uses little-endian by default, but big_endian for better readability in the picture above.</em></p>
<h3 id="account-storage"><a class="header" href="#account-storage">Account Storage</a></h3>
<p>User-defined data that can be stored in an account. <code>AccountStorage</code> is composed of two components.</p>
<p>The first component is a simple sparse Merkle tree of depth <code>8</code> which is index addressable. This provides the user with <code>256</code> <code>Word</code> slots.</p>
<p>Users requiring additional storage can use the second component a <code>MerkleStore</code>. It allows users to store any Merkle structures they need. The root of the Merkle structure can be stored as a leaf in the simple sparse Merkle tree. When <code>AccountStorage</code> is serialized it will check to see if any of the leafs in the simple sparse Merkle tree are Merkle roots of other Merkle structures. If any Merkle roots are found then the Merkle structures will be persisted in the <code>AccountStorage</code> <code>MerkleStore</code>.</p>
<h3 id="nonce"><a class="header" href="#nonce">Nonce</a></h3>
<p>Counter which must be incremented whenever the account state changes. Nonce values must be strictly monotonically increasing and can be incremented by any value smaller than 2^{32} for every account update.</p>
<h3 id="vault"><a class="header" href="#vault">Vault</a></h3>
<p>Asset container for an account.</p>
<p>An account vault can contain an unlimited number of <a href="https://0xpolygonmiden.github.io/miden-base/architecture/assets.html">assets</a>. The assets are stored in a sparse
Merkle tree as follows:</p>
<ul>
<li>For fungible assets, the index of a node is defined by the issuing faucet ID, and the value
of the node is the asset itself. Thus, for any fungible asset there will be only one node
in the tree.</li>
<li>For non-fungible assets, the index is defined by the asset itself, and the asset is also
the value of the node.</li>
</ul>
<p>An account vault can be reduced to a single hash which is the root of the sparse Merkle tree.</p>
<h3 id="code"><a class="header" href="#code">Code</a></h3>
<p>Interface for accounts. In Miden every account is a smart contract. It has an interface that exposes functions that can be called by note scripts. Functions exposed by the account have the following properties:</p>
<ul>
<li>Functions are actually roots of <a href="https://0xpolygonmiden.github.io/miden-vm/user_docs/assembly/main.html">Miden program MASTs</a> (i.e., 32-byte hash). Thus, function identifier is a commitment to the code which is executed when a function is invoked.</li>
<li>Only account functions have mutable access to an account's storage and vault. Therefore, the only way to modify an account's internal state is through one of account's functions.</li>
<li>Account functions can take parameters and can create new notes.</li>
</ul>
<p><em>Note: Since code in Miden is expresed as MAST, every function is a commitment to the underlying code. The code cannot change unnoticed to the user because its hash would change. Behind any MAST root there can only be <code>256</code> functions</em></p>
<h2 id="account-creation"><a class="header" href="#account-creation">Account creation</a></h2>
<p>For an account to exist it must be present in the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/state.html#account-database">Account DB</a> kept by the Miden Node(s). However, new accounts can be created locally by users using a wallet.</p>
<p>The process is as follows:</p>
<ul>
<li>Alice grinds a new Account ID (according to the account types) using a wallet</li>
<li>Alice's Miden Client requests the Miden Node to check if new Account ID already exists</li>
<li>Alice shares the new Account ID to Bob (eg. when Alice wants to receive funds)</li>
<li>Bob executes a transaction and creates a note that contains an asset for Alice</li>
<li>Alice consumes Bob's note to receive the asset in a transaction</li>
<li>Depending on the account storage mode (private vs. public) and transaction type (local vs. network) the Operator receives new Account ID eventually and - if transaction is correct - adds the ID to the Account DB</li>
</ul>
<h2 id="account-storage-modes"><a class="header" href="#account-storage-modes">Account storage modes</a></h2>
<p>Account data - stored by the Miden Node - can be public, private, or encrypted. The third and fourth most significant bits of the account ID specifies whether the account data is public <code>00</code>, encrypted <code>01</code>, or private <code>11</code>.</p>
<ul>
<li>Accounts with <strong>public state</strong>, where the actual state is stored onchain. These would be similar to how accounts work in public blockchains. Smart contracts that depend on public shared state should be stored public on Miden, e.g., DEX contract.</li>
<li>Account with <strong>encrypted state</strong>, where the account data is stored onchain but in encrypted text. It provides liveness guarantee of the protocol for the account in question.</li>
<li>Accounts with <strong>private state</strong>, where only the hash of the account is stored onchain. Users who want stay private and take care of their own data should choose this mode. The hash is defined as: <code>hash([account ID, 0, 0, nonce], [vault root], [storage root], [code root])</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="notes-1"><a class="header" href="#notes-1">Notes</a></h1>
<p>Miden aims to achieve parallel transaction execution and privacy. The UTXO-model combined with client-side proofs provide those features. In Miden, an note is a way of transferring assets between accounts. Notes can be consumed and produced asynchronously and privately.</p>
<h2 id="note-design"><a class="header" href="#note-design">Note design</a></h2>
<p>The diagram below illustrates the contents of a note:</p>
<p align="center">
    <img src="architecture/../diagrams/architecture/note/Note.png">
</p>
<p>As shown in the above picture:</p>
<ul>
<li><strong>Vault →</strong> a set of assets that are stored in note</li>
<li><strong>Script →</strong> it must be executed in a context of some account to claim the assets</li>
<li><strong>Inputs →</strong> these are placed onto the stack before a note's script is executed</li>
<li><strong>Serial number →</strong> a note's unique identifier</li>
</ul>
<h3 id="vault-1"><a class="header" href="#vault-1">Vault</a></h3>
<p>Asset container for a note. A note vault can contain up to <code>255</code> assets stored in an array. The entire vault can be reduced to a single hash which is computed by sequentially hashing the list of the vault's assets.</p>
<h3 id="script"><a class="header" href="#script">Script</a></h3>
<p>Unlike an account, a note has a single executable script. This script will be executed in a <a href="https://0xpolygonmiden.github.io/miden-base/architecture/transactions.html">transaction</a>. This script is also the root of a <a href="https://0xpolygonmiden.github.io/miden-vm/user_docs/assembly/main.html">Miden program MAST</a>. A script is always executed in the context of a single account, and thus, may invoke account's functions. A note's script can call zero or more of an account's function.</p>
<p><em>Note: Since code in Miden is expresed as MAST, every function is a commitment to the underlying code. The code cannot change unnoticed to the user because its hash would change.</em></p>
<h3 id="inputs"><a class="header" href="#inputs">Inputs</a></h3>
<p>A note script can take parameters (passed via the stack) as inputs.</p>
<h3 id="serial-number"><a class="header" href="#serial-number">Serial number</a></h3>
<p>A note's unique serial number identifies the note and this is needed to create the note's hash and nullifier. The serial number is used to break linkability between note hash and note nullifier.</p>
<h2 id="note-metadata"><a class="header" href="#note-metadata">Note metadata</a></h2>
<p>For every note the Miden Operator stores metadata in the Note DB. This metadata includes:</p>
<ul>
<li>A <strong>user-defined tag</strong> as a means to quickly grab all notes for a certain application or use case.</li>
<li>A <strong>sender</strong> to be able to provide also ERC20 contract functionality.</li>
<li>The <strong>number of assets</strong> contained in the note.</li>
</ul>
<h2 id="note-storage-modes"><a class="header" href="#note-storage-modes">Note storage modes</a></h2>
<p>Similar to accounts, there are two storage modes for notes in Miden. Notes can be stored privately in the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/state.html#notes-database">Notes DB</a> with only the note hash. Or notes can be stored publicly with all data.</p>
<p>Privately stored notes can only be consumed if the note data is known to the consumer. That means, there must be some offchain communication to transmit the note's data from the sender to the receipient.</p>
<h2 id="note-hash"><a class="header" href="#note-hash">Note hash</a></h2>
<p>The note hash is computed as:</p>
<p><code>hash(hash(hash(hash(serial_num, [0; 4]), script_hash), input_hash), vault_hash)</code></p>
<p>This achieves the following properties:</p>
<ul>
<li>Every note can be reduced to a single unique hash.</li>
<li>To compute a note's hash, we do not need to know the note's <code>serial_num</code>. Knowing the hash
of the <code>serial_num</code> (as well as <code>script_hash</code>, <code>input_hash</code> and <code>note_vault</code>) is sufficient.</li>
<li>Moreover, we define <code>recipient</code> as: <code>hash(hash(hash(serial_num, [0; 4]), script_hash), input_hash)</code>. This allows computing the note hash from recipient and note vault.</li>
<li>We compute the hash of <code>serial_num</code> as <code>hash(serial_num, [0; 4])</code> to simplify processing within
the VM.</li>
</ul>
<h2 id="note-nullifier"><a class="header" href="#note-nullifier">Note nullifier</a></h2>
<p>The nullifier is the note's index in the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/state.html#nullifier-database">Nullifier DB</a>. The Nullifier DB stores the information whether a note was already consumed.</p>
<p>The nullifier is computed as <code>hash(serial_num, script_hash, input_hash, vault_hash)</code>.</p>
<p>This achieves the following properties:</p>
<ul>
<li>Every note can be reduced to a single unique nullifier.</li>
<li>We cannot derive a note's hash from its nullifier.</li>
<li>To compute the nullifier, we must know all components of the note: <code>serial_num</code>, <code>script_hash</code>, <code>input_hash</code>, and <code>vault_hash</code>.</li>
</ul>
<p>To know a note’s nullifier, one needs to know all details of the note. That means if a note is private and the operator stores only the note's hash, only those with the note details know if this note has been consumed already. Zcash first introduced this approach.</p>
<p align="center">
    <img src="architecture/../diagrams/architecture/note/Nullifier.png">
</p>
<h2 id="note-lifecycle"><a class="header" href="#note-lifecycle">Note lifecycle</a></h2>
<p>For a note to exist it must be present in the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/state.html#notes-database">Notes DB</a> kept by the Miden Node(s). New notes are being produced when executing a transaction. They can be produced locally by users in local transactions or by the operator in a network transaction.</p>
<p>The lifcycle of a note is as follows:</p>
<ul>
<li>A new note is produced when a transaction is executed - regardless of the transaction type</li>
<li>Operator will receive the note hash and if the note is public, it'll also receive the corresponding note's data</li>
<li>Operator verifies the correctness of the underlying transaction before adding the note hash to the Notes DB</li>
<li>The note can now be consumed in a seperate transaction - to consume the note, the note's data must be known</li>
<li>A note is consumed when the its nullifier in the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/state.html#nullifier-database">Nullifier DB</a> is set to <code>1</code></li>
<li>Operator will receive the note's nullifier together with a transaction proof</li>
<li>After successful verification, the Operator sets the corresponding entry in the Nullifier DB to <code>1</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="assets-1"><a class="header" href="#assets-1">Assets</a></h1>
<p>In Miden, users can create and trade arbitrary fungible and non-fungible assets.</p>
<p>We differentiate between native and non-native assets in Miden. Native assets follow the Miden asset model. Non-native assets are all other data structures of value that can be exchanged.</p>
<p>Recording of native assets in Polygon Miden suffices four goals:</p>
<ul>
<li>Asset exchange should be parallelizable</li>
<li>Asset ownership should be private</li>
<li>Asset usage should be indeed censorship resistant</li>
<li>Fees can be paid using any asset</li>
</ul>
<p>All native assets in Miden are stored directly in accounts, like Ether in Ethereum. Miden does not track ownership of assets using global hashmaps, e.g., ERC20 contracts. Storage of assets locally in accounts provides privacy and the ability for client-side proofs. That is because ownership changes always involve only one account and not the change of a global hashmap. Thus, they can happen in parallel. Additionally, asset exchange is censorship resistant at this level because there is no global contract the transfer must pass through. Finally, users can pay fees in any asset.</p>
<h2 id="native-assets"><a class="header" href="#native-assets">Native assets</a></h2>
<p>Native assets are data structures that follow the Miden asset model (encoding, issuance, storing). All native assets are encoded using a single <code>Word</code> (4 field elements). The asset encodes both the ID of the issuing account and the asset details. Having the issuer's ID encoded in the asset makes it cost-efficient to determine the type of an asset inside and outside Miden VM. And, representing the asset in a <code>Word</code> means the representation is always a commitment to the asset data itself. That is particularly interesting for non-fungible assets.</p>
<h3 id="issuance"><a class="header" href="#issuance">Issuance</a></h3>
<p>Only specialized accounts called faucets can issue assets. Just like with regular accounts, anyone can create a faucet account. Faucets can issue only either fungible or non-fungible assets - but not both. The <code>faucet_id</code> identifies the faucet and is starts with a different sequence depending on the asset type, see <a href="https://0xpolygonmiden.github.io/miden-base/architecture/accounts.html#account-id">here</a>. The faucet's code defines rules for how assets can be minted, who can mint them etc. Conceptually, faucet accounts on Miden are similar to ERC20 contracts on Ethereum. But, there is no ownership tracking in Miden faucets.</p>
<p>Faucets can create assets and immediately distribute them by producing notes. However, assets can also stay in the faucet after creation to be sent later, e.g., in a bundle. That way, one can mint a million NFTs locally in a single transaction and then send them out as needed in separate transactions in the future.</p>
<p align="center">
    <img src="architecture/../diagrams/architecture/asset/Asset_Issuance.png">
</p>
<h3 id="fungible-assets"><a class="header" href="#fungible-assets">Fungible assets</a></h3>
<p>A fungible asset is encoded using the amount and the <code>faucet_id</code> of the faucet which issued the asset. The amount is guaranteed to be  <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">63</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> or smaller, the maximum supply for any fungible asset. Examples of fungible assets are ETH and stablecoins, e.g., DAI, USDT, and USDC.</p>
<p>If the <code>faucet_id</code> of MATIC were to be <code>2</code>, 100 MATIC are encoded as <code>[100, 0, 0, 2]</code> - whereas the <code>0</code>s in the middle help to quickly distinguish between fungible and non-fungible assets.</p>
<h3 id="non-fungible-assets"><a class="header" href="#non-fungible-assets">Non-fungible assets</a></h3>
<p>A non-fungible asset is encoded by hashing the asset data into a <code>Word</code> and then replacing the second element with the <code>faucet_id</code> of the issuing account. It looks like <code>[e0, faucet_id, e2, e3]</code>. Note that the second element is guaranteed to be non-Zero.</p>
<p>Examples of non-fungible assets are all NFTs, e.g., a DevCon ticket. The ticket's data might be represented in a JSON string - which DevCon, the date, the initial price, etc. . Now, users can create a faucet for non-fungible DevCon tickets. This DevCon faucet would hash the JSON string into a <code>Word</code> to transform the ticket into an asset.</p>
<h3 id="storage"><a class="header" href="#storage">Storage</a></h3>
<p><a href="https://0xpolygonmiden.github.io/miden-base/architecture/accounts.html">Accounts</a> and <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html">notes</a> contain asset vaults that are used to store assets. Accounts can keep unlimited assets in a <a href="https://0xpolygonmiden.github.io/miden-base/crypto-primitives/tsmt.html">tiered sparse Merkle tree</a> called <code>account vault</code>. Notes can only store up to <code>255</code> distinct assets.</p>
<p align="center">
    <img src="architecture/../diagrams/architecture/asset/Asset_Storage.png">
</p>
<p>The information on which and how many assets are owned can be private depending on the account's storage mode or the note. This is true for any native asset in Miden.</p>
<h2 id="non-native-assets"><a class="header" href="#non-native-assets">Non-native assets</a></h2>
<p>Miden is flexible enough to create other types of assets as well.</p>
<p>For example, developers can fully replicate Ethereum's ERC20 model, where ownership of fungible assets is recorded in a single account. To transact, users must send a note to that account to change the global hashmap.</p>
<p>Furthermore, a complete account can be treated as a programmable asset because ownership of accounts is transferrable. An account could be a &quot;crypto kitty&quot; with specific attributes and rules, and people can trade these &quot;crypto kitties&quot; by transferring accounts between each other.</p>
<p>We can also think of an account representing a car. The owner of the car can change so the car account - granting access to the physical car - can be treated as an asset. In this car account, there could be rules defining who is allowed to drive the car and when.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="transactions-1"><a class="header" href="#transactions-1">Transactions</a></h1>
<p>Asset transfers between accounts are done by executing transactions. Miden aims for parallel and private transaction execution. Therefore, a transaction is always performed against a single account which provides asynchronicity. And, every transaction causes a provable state-change and a STARK proof thereof. Thus, when executed locally, it provides privacy.</p>
<h2 id="transaction-design"><a class="header" href="#transaction-design">Transaction design</a></h2>
<p>Transactions can be described as state-transition function T that takes an account and <code>0 to n</code> notes to map it to another version of that account and produces <code>0 to n</code> notes</p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1685em;vertical-align:-0.4185em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1691em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6698em;"><span style="top:-2.7102em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mtight"><span class="mord mtight">0</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">i</span><span class="mrel mtight">&lt;</span><span class="mord mtight">1024</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1698em;"><span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4185em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1755em;vertical-align:-0.4236em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1742em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.7175em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mtight"><span class="mord mtight">0</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&lt;</span><span class="mord mtight">4096</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.177em;"><span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4236em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">))</span></span></span></span>
, where  <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mord mathnormal">cco</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span></span></span></span></span>, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">es</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></p>
<p>A transaction must include an executable program in addition to inputs and outputs. The transaction program has a well-defined structure and must perform the following functions:</p>
<ol>
<li>Create a uniform vault for all inputs.</li>
<li>Run scripts for all input notes (scripts are run one after the other).</li>
<li>Run a user-defined script if desired.</li>
<li>Create a uniform vault for all outputs.</li>
<li>Ensure that the assets in the unified input and output vaults are the same.</li>
</ol>
<h3 id="transaction-inputs-and-outputs"><a class="header" href="#transaction-inputs-and-outputs">Transaction inputs and outputs</a></h3>
<p>As inputs, a transaction accepts the state of one single account and up to <code>1023</code> notes for consumption. Optionally, it also takes a user defined script which is executed after all input notes have been consumed. The transaction's output will consist of that single account and up to <code>4096</code> newly created notes.</p>
<h3 id="transaction-program"><a class="header" href="#transaction-program">Transaction program</a></h3>
<p>In addition to specifying inputs and outputs, a transaction must also include an executable program. The transaction program has a well-defined structure which must do the following:</p>
<p>A user-defined transaction script can also be included in a transaction.</p>
<p>The last point ensures that a transaction does not create or destroy any assets. A transaction can also include a user-defined transaction script. A transaction script is different to the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#script">note scripts</a> that are executed during a transaction.</p>
<h2 id="execution-steps-of-a-transaction"><a class="header" href="#execution-steps-of-a-transaction">Execution steps of a transaction</a></h2>
<p>Transaction execution consists of several steps. These steps are described below:</p>
<ol>
<li><strong>Prologue</strong>: during this step we build a single unified vault all all transaction inputs (account + notes).</li>
<li><strong>Execution</strong>: during this step we first execute scripts of all input notes (one after another), and then execute an optional user-defined script (called tx script).</li>
<li><strong>Epilogue</strong>: during this step we build a single unified vault of all transaction outputs (account + notes), and make sure it contains the same assets as the input vault.</li>
</ol>
<h2 id="asset-transfer-using-two-transactions"><a class="header" href="#asset-transfer-using-two-transactions">Asset transfer using two transactions</a></h2>
<p>Under this model transferring assets between accounts requires two transactions as shown in the diagram below.</p>
<p align="center">
    <img src="architecture/../diagrams/architecture/transaction/Transaction_Flow.png">
</p>
<p>The first transaction invokes a function on <code>account_a</code> (e.g., &quot;send&quot; function) which creates a new note and also updates the internal state of <code>account_a</code>. The second transaction consumes the note which invokes a function on <code>account_b</code> (e.g., &quot;receive&quot; function), which also updates the internal state of <code>account_b</code>.</p>
<p>It is important to note that both transactions can be executed asynchronously: first <code>transaction1</code> is executed, and then, some time later, <code>transaction2</code> can be executed. This opens up a few interesting possibilities:</p>
<ul>
<li>Owner of <code>account_b</code> may wait until there are many notes sent to them and process all incoming notes in a single transaction.</li>
<li>A note script may include a clause which allows the source account to consume the note after some time. Thus, if <code>account_b</code> does not consume the note after the specified time, the funds can be returned. This mechanism could be used to <strong>make sure funds sent to non-existent accounts are not lost</strong>.</li>
<li>Neither sender nor the recipient need to know who the other side is. From the sender's perspective they just need to create <code>note1</code> (and for this they need to know the assets to be transferred and the root of the note's script). They don't need any information on who will eventually consume the note. From the recipient's perspective, they just need to consume <code>note1</code>. They don't need to know who created it.</li>
<li>Both transactions can be executed &quot;locally&quot;. For example, we could generate a ZKP proving that <code>transaction1</code> was executed and submit it to the network. The network can verify the proof without the need for executing the transaction itself. Same can be done for <code>transaction2</code>. Moreover, we can mix and match. For example, <code>transaction1</code> can be executed locally, but <code>transaction2</code> can be executed on the network, or vice-versa.</li>
</ul>
<h2 id="local-vs-network-transactions"><a class="header" href="#local-vs-network-transactions">Local vs. network transactions</a></h2>
<p>There are two types of transactions in Miden: local transactions and network transactions.</p>
<p align="center">
    <img src="architecture/../diagrams/architecture/transaction/Local_vs_Network_Transaction.png">
</p>
<p>For <strong>local transactions</strong>, clients executing the transactions also generate the proofs of their correct execution. So, no additional work needs to be performed by the network. Local transactions are useful for several reasons:</p>
<ol>
<li>They are cheaper (i.e., lower fees) as ZKPs are already generated by the clients.</li>
<li>They allow fairly complex computations because the proof size doesn't grow linearly with the complexity of the computation.</li>
<li>They enable privacy as neither the account state nor account code are needed to verify the ZKP.</li>
</ol>
<p>For <strong>network transactions</strong>, the operator will execute the transaction and generate the proofs. Network transactions are useful for two reasons:</p>
<ol>
<li>Clients may not have sufficient resources to generate ZK proofs.</li>
<li>Executing many transactions against the same public account by different clients would be challenging as the account state would change after every transaction. In this case, the Miden Node / Operator acts as a &quot;synchronizer&quot; as they can execute transactions sequentially and feed the output of the previous transaction into the subsequent one.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="state"><a class="header" href="#state">State</a></h1>
<p>The state of the Miden rollup describes the current condition of all accounts and note states. It describes what is currently the case. With its state model, using concurrent offchain state, Polygon Miden aims to realise private transactions, and execution and state bloat minimization.</p>
<p>Privacy is realised from a UTXO-like state model consisting of notes and nullifiers combined with offchain execution using zero-knowledge proofs. Execution bloat happens when transactions get re-executed by all participants of the network. State bloat describes the ever growing state stored in blockchain nodes. Polygon Miden addresses these challenges via its state model that enables concurrent offchain execution and offchain storage.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Minimize execution bloat</th><th>Minimize state bloat</th></tr></thead><tbody>
<tr><td><strong>Result of</strong></td><td>Verfifying state by re-executing</td><td>Storing all data onchain as state</td></tr>
<tr><td><strong>Zero-knowledge helps with</strong></td><td>Transactions executed only once</td><td>No need to know full state to validate blocks</td></tr>
<tr><td><strong>Concurrent state model helps with</strong></td><td>Transactions executed concurrently by distinct actors</td><td>No need to kow full state to produce blocks</td></tr>
</tbody></table>
</div>
<h2 id="state-components"><a class="header" href="#state-components">State components</a></h2>
<p>The Miden Node(s) maintain three databases to describe the state:</p>
<ol>
<li>A database of accounts.</li>
<li>A database of notes.</li>
<li>A database of nullifiers for already consumed notes.</li>
</ol>
<p align="center">
  <img src="architecture/../diagrams/architecture/state/State.png" width="80%">
</p>
<p>These databases are represented by authenticated data structures, such that we can easily prove that items were added to or removed from a database, and a commitment to the database would be very small.</p>
<p>Polygon Miden has two databases to capture the note states. The note database is append-only and stores all notes permanently. The nullifier database stores nullifiers that indicate that a note has been previsously consumed. Separating note storage into these two databases gives Polygon Miden client-side proving and advanced privacy.</p>
<h3 id="account-database"><a class="header" href="#account-database">Account database</a></h3>
<p>The latest account states - and data for onchain accounts - are recorded in a <a href="https://0xpolygonmiden.github.io/miden-base/crypto-primitives/tsmt.html">tiered sparse Merkle tree</a> which maps account IDs to account hashes and account data if needed.</p>
<p align="center">
  <img src="architecture/../diagrams/architecture/state/Account_DB.png" width="80%">
</p>
<p>As described in <a href="http://localhost:3000/architecture/accounts.html#account-storage-modes">Accounts</a>, there are three types of accounts:</p>
<ul>
<li><strong>Public accounts</strong> where all account data is stored onchain.</li>
<li><strong>Encrypted accounts</strong> where where the account data is stored onchain but in encrypted text.</li>
<li><strong>Private accounts</strong> where only the hashes of accounts are stored onchain.</li>
</ul>
<p>Private accounts significantly reduce the storage overhead for nodes. A private account contributes only <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">40</span></span></span></span> bytes to the global state (<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span> bytes account ID + <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> bytes account hash). Or, said another way, 1 billion private accounts takes up only <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">40</span></span></span></span> GB of state.</p>
<blockquote>
<p>Losing the state of a private account would mean loss of funds (as the user won't be able to execute transactions) in a similar manner as a loss of a private key would. This problem can be easily mitigated by storing encrypted account state in a cloud or backing it up somewhere else. Unlike storing private keys in the cloud, this does not compromise privacy or security of an account.</p>
</blockquote>
<h3 id="note-database"><a class="header" href="#note-database">Note database</a></h3>
<p>Notes are recorded in an append-only accumulator, a <a href="https://github.com/opentimestamps/opentimestamps-server/blob/master/doc/merkle-mountain-range.md">Merkle Mountain Range</a>. Each leaf is a block header which contains the commitment to all notes created in that block. The size of the Merkle Mountain Range grows logarithmically with the number of items in it.</p>
<p align="center">
  <img src="architecture/../diagrams/architecture/state/Note_DB.png" width="80%">
</p>
<p>As described in <a href="http://localhost:3000/architecture/notes.html#note-storage-modes">Notes</a>, there are two types of <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html">notes</a>:</p>
<ul>
<li><strong>Public notes</strong> where the entire note content is recorded in the state.</li>
<li><strong>Private notes</strong> where only a note's hash is recorded in the state.</li>
</ul>
<p>As with accounts, there is a strong incentive to use private notes as they result in lower fees. This is also beneficial to the network as a private note adds only <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span></span></span></span> bytes to the state (<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> bytes when it is produced, and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> bytes when it is consumed).</p>
<p>Using a Merkle Mountain Range (append-only accumulator) is important for two reasons:</p>
<ol>
<li>Membership witnesses (a note exists in the database) against such an accumulator needs to be updated very infrequently.</li>
<li>Old membership witnesses can be extended to be used with a new accumulator value, but this extension does not need to be done by the original witness holder.</li>
</ol>
<p>Both of these properties are needed for supporting local transactions using client-side proofs and privacy. In an append-only data structure, this witness data does not become stale when the data structure is updated. That means users can generate valid proofs even if they don’t have the latest state of this database, so there is no need to query the operator on a constantly changing state.</p>
<p>However, the size of the note database does not grow indefinitely. Theoretically, at high tps, it would grow very quickly: at <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>K TPS there would be about <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>TB/year added to the database. But, only the unconsumed public notes and enough info to construct membership proofs against them need to be stored explicitly. Private notes, as well as public notes which have already been consumed, can be safely discarded. Such notes would still remain in the accumulator, but there is no need to store them explicitly as the append-only accumulator can be updated without knowing all items stored in it. This reduces actual storage requirements to a fraction of the database's nominal size.</p>
<h3 id="nullifier-database"><a class="header" href="#nullifier-database">Nullifier database</a></h3>
<p>Nullifiers are stored in a <a href="https://0xpolygonmiden.github.io/miden-base/crypto-primitives/tsmt.html">Tiered Sparse Merkle Tree</a>, which maps <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-nullifier">Note Nullifiers</a> to <code>0</code> or <code>1</code>. Nullifiers provide information on whether a specific note has been consumed yet. The database allows proving that a given nullifier is not in the database.</p>
<p align="center">
  <img src="architecture/../diagrams/architecture/state/Nullifier_DB.png">
</p>
<p>To prove that a note has not been consumed previously, the operator needs to provide a Merkle path to its node, and then show that the value in that node is <code>0</code>. In our case nullifiers are <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> bytes each, and thus, the height of the Sparse Merkle tree need to be <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span>.</p>
<p>To be able to add new nullifiers to the database, Operators needs to maintain the entire nullifier set. Otherwise, they would not be able to compute the new root of the tree.</p>
<p>*Note: Nullifiers as constructed in Miden break linkability of privately stored notes and the information about the note's consumption. To know the <a href="https://0xpolygonmiden.github.io/miden-base/architecture/notes.html#note-nullifier">note's nullifier</a> one must know the note's data.</p>
<p>There will be one tree per epoch (~3 months), and Miden nodes always store trees for at least two epochs. However, the roots of the old trees are still stored. If a user wants to consume a note that is more than <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span> month old, there must be a merkle path provided to the Miden Node for verification.</p>
<h2 id="state-bloat-minimization"><a class="header" href="#state-bloat-minimization">State bloat minimization</a></h2>
<p>Operators don’t need to know the entire state to verify or produce a new block. No operator is required to store the entire state.</p>
<p>At its core, the idea is simple: Instead of storing the full state data with the operators, the users store their data, and the rollup only keeps track of commitments to the data. At least for private accounts, some smart contracts need to be publicly visible. This minimizes state bloat—as the operator doesn’t need to store an ever-growing database—and provides privacy because all other users and the operator only see a hash of other users’ data.</p>
<p>That way the account and note databases can remain manageable, even at high usage for extended periods of time.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="execution-model-1"><a class="header" href="#execution-model-1">Execution Model</a></h1>
<p>Polygon Miden is an Ethereum Rollup. It batches transactions - or more precisely, proofs thereof - that happen together in the same time period into a block. The Execution Model describes how the state progresses on <strong>an individual level via transactions</strong> and <strong>at the global level expressed as aggregated state updates in blocks</strong>.</p>
<p align="center">
  <img src="architecture/../diagrams/architecture/execution/Execution.png">
</p>
<h2 id="transaction-execution"><a class="header" href="#transaction-execution">Transaction Execution</a></h2>
<p>Every transaction will result in a ZK proof that attests to its correctness.</p>
<p>As mentioned in <a href="https://0xpolygonmiden.github.io/miden-base/architecture/transactions.html#local-vs-network-transactions">transactions</a>, there are two types of transactions: local and network. For every transaction there is a proof which is either created by the user in the Miden Client or by the Operator using the Miden Node.</p>
<h2 id="transaction-batching"><a class="header" href="#transaction-batching">Transaction Batching</a></h2>
<p>To reduce the required space on the Ethereum blockchain, transaction proofs are aggregated into batches. This can happen in parallel by different machines that need to verify several proofs using the Miden VM and thus creating a proof. Verifying a STARK proof within the VM is relatively efficient but it is still a pretty costly operation (we aim for 2<sup>16</sup> cycles).</p>
<h2 id="block-production"><a class="header" href="#block-production">Block Production</a></h2>
<p>Several batch proofs are being aggregated together into one block. This can not happen in parallel and must be done by the Miden Operator running the Miden Node. The idea is the same, using recursive verification.</p>
<h2 id="state-progress"><a class="header" href="#state-progress">State progress</a></h2>
<p>At the beginning, Miden will have a centralized Operator running a Miden Node.</p>
<p>Users will send either transaction proofs (using local execution) or transaction data (for network execution) to the Miden Node. Later on, the Miden Node will use recursive verification to aggregate transaction proofs into batches.</p>
<p>Batch proofs are aggregated into blocks by the Miden Node. The blocks are then sent to Ethereum, and once a block is added to the L1 chain, the rollup chain is believed to have progressed to the next state.</p>
<p>A block produced by the Miden Node looks somewhat like this:</p>
<p align="center">
  <img src="architecture/../diagrams/architecture/execution/Block.png">
</p>
<ul>
<li><strong>state updates</strong> contain only the hashes of changes. For example, for each account which was updated, we record a tuple <code>([account id], [new account hash])</code>.</li>
<li>The included <strong>zk proof</strong> attests that given a state commitment from the previous block, there was a sequence of valid transactions executed that resulted in the new state commitment, and also output included state updates.</li>
<li>The block also contains full account and note data for public accounts and notes. For example, if account <code>123</code> is a public account which was updated, in the <em>state updates</em> section we'd have a records for it as <code>(123, 0x456..)</code>. The full new state of this account (which should hash to <code>0x456..</code>) would be included in a separate section.</li>
</ul>
<p>To verify that a block describes a valid state transition, we do the following:</p>
<ol>
<li>Compute hashes of public account and note states.</li>
<li>Make sure these hashes match records in the <em>state updates</em> section.</li>
<li>Verify the included ZKP against the following public inputs:
<ul>
<li>State commitment from the previous block.</li>
<li>State commitment from the current block.</li>
<li>State updates from the current block.</li>
</ul>
</li>
</ol>
<p>The above can be performed by a verifier contract on Ethereum L1.</p>
<p>This structure has another nice property. It is very easy for a new node to sync up to the current state from genesis. The new node would need to do the following:</p>
<ol>
<li>Download only the first part of the blocks (i.e., without full account/note states) starting at the genesis up until the latest block.</li>
<li>Verify all ZKPs in the downloaded blocks. This will be super quick (exponentially faster than re-executing original transactions) and can also be done in parallel.</li>
<li>Download the current states of account, note, and nullifier databases.</li>
<li>Verify that the downloaded current state matches the state commitment in the latest block.</li>
</ol>
<p>Overall, state sync is dominated by the time needed to download the data.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="polygon-miden-network-wip"><a class="header" href="#polygon-miden-network-wip">Polygon Miden Network [WIP]</a></h1>
<p>Polygon Miden is a bi-directional token bridge and state machine. Miden Nodes act as operators that keep the state and compress state transitions recursively into STARK-proofs. The token bridge on Ethereum verifies these proofs. Users can run Miden clients to send RPC requests to the Miden Nodes to update the state.</p>
<p>The major components of Polygon Miden are:</p>
<ul>
<li>Miden Clients - represent Miden users</li>
<li>Miden Nodes - manage the Miden rollup and compress proofs</li>
<li>Verifier Contract - keeps and verifies state on Ethereum</li>
<li>Bridge Contract - entry and exit point for users</li>
</ul>
<h2 id="network-slide"><a class="header" href="#network-slide">Network Slide</a></h2>
<p><img src="diagrams/network/Architecture_Overview.svg" alt="Miden Architecture Overview" /></p>
<h2 id="miden-clients"><a class="header" href="#miden-clients">Miden Clients</a></h2>
<p>Users will run Miden Clients. They are designed to provide an interface for wallets representing accounts on Miden. Miden Clients can execute and prove transactions in the Tx Prover. They can handle arbitrary signature schemes - whereas the default is Falcon. The wallet interface serves a user interface, a wallet database to be able to store account data locally, and the required smart contract code that represents the account on Miden.</p>
<p>Want to learn more about Miden Clients? See <a href="network/miden-clients.html">here</a>.</p>
<h2 id="miden-nodes"><a class="header" href="#miden-nodes">Miden Nodes</a></h2>
<p>Operators will run Miden Nodes. Operators ensure integrity of the Account, Note and Nullifier State - which represent the state of Polygon Miden. Operators can execute and proof transactions against single accounts and they can verify proofs of locally executed transactions. Furthermore, the operator compresses the proofs in several steps up to a single proofs that gets published and verified on the Verifier contract. Operators also watch events emitted by the Bridge Contract to detect deposits and withdrawals.</p>
<p>To manage all of this, Miden Nodes have different modules. The Node orchestrates a Tx Prover, a Tx Aggregator and a Block Producer. The Tx Prover executes and proves transactions, like in the Miden Client. The Tx Aggregator can batch multiple proofs together to reduce the final state proof size using recursive proving. The Block Producer exposes the RPC interface to the user. The Block Producer collects transactions in the Tx Pool and stores the state of Polygon Miden in its three databases (Accounts, Notes, Nullifiers).</p>
<p>Want to learn more about Miden Nodes? See <a href="network/miden-node.html">here</a>.</p>
<h2 id="verifier-contract"><a class="header" href="#verifier-contract">Verifier Contract</a></h2>
<p>This contract on Ethereum verifies proofs sent by the operator running a Miden Node. The proof is verified against the current state root. If accepted the state root changes.</p>
<p>Want to learn more about Miden Nodes? See <a href="network/verifier-contract.html">here</a>.</p>
<p>[This is a dummy text, we need to explain the contract in detail]</p>
<h2 id="bridge-contract"><a class="header" href="#bridge-contract">Bridge Contract</a></h2>
<p>This contract serves the Miden users on Ethereum as bridge. Users can deposit their tokens and get an equivalent amount minted and sent to the specified address on Polygon Miden.</p>
<p>Want to learn more about the bridge? See <a href="network/bridge.html">here</a>.</p>
<p>[This is a dummy text, we need to explain the contract in detail]</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="miden-clients-1"><a class="header" href="#miden-clients-1">Miden Clients</a></h1>
<p>Users use Miden Clients to interact in the network. The backend of any wallet that is used in Miden will be a Miden Client. Miden Clients consist of several components.</p>
<ul>
<li>Transaction Prover</li>
<li>Signature module</li>
<li>Wallet interface</li>
<li>Wallet database</li>
</ul>
<p>[We need a diagram to show the Miden Client]</p>
<h2 id="transaction-prover"><a class="header" href="#transaction-prover">Transaction Prover</a></h2>
<p>The Transaction Prover is able to execute transactions and create transaction execution proofs. It runs a Transaction Kernel at its heart.</p>
<h2 id="signature-module"><a class="header" href="#signature-module">Signature module</a></h2>
<p>[Unclear if this is a separate module]</p>
<h2 id="wallet-interface"><a class="header" href="#wallet-interface">Wallet interface</a></h2>
<p>At the beginning we only have a basic wallet interface which we implement for the testnet. It is rather simplistic.</p>
<p>The interface defines three methods:</p>
<pre><code>receive_asset
send_asset
auth_tx
</code></pre>
<p>The first two of the above methods should probably be an interface on their own, and we should recommend that most accounts implement these methods.</p>
<p>The goal is to provide a wallet with the following capabilities:</p>
<p>The wallet is controlled by a single key. The signature scheme is assumed to be Falcon. However, sending assets to the wallet does not require knowing which signature scheme is used by the recipient. The user can send, receive, and exchange assets stored in the wallet with other users. All operations (including receiving assets) must be authenticated by the account owner.</p>
<p>Interface method description
Below, we provide high-level details about each of the interface methods.</p>
<h3 id="receive_asset-method"><a class="header" href="#receive_asset-method"><code>receive_asset method</code></a></h3>
<p>The purpose of this method is to add a single asset to an account's vault. Pseudo-code for this method could look like so:</p>
<pre><code>receive_asset(asset)
    self.add_asset(asset)
end
</code></pre>
<p>In the above, <code>add_asset</code> is a kernel procedure <code>miden::sat::account::add_asset</code> of the Tx Kernel.</p>
<p>Note: this method does not increment account nonce. The nonce will be incremented in auth_tx method described below. Thus, receiving assets requires authentication.</p>
<h3 id="send_asset-method"><a class="header" href="#send_asset-method"><code>send_asset method</code></a></h3>
<p>The purpose of this method is to create a note which sends a single asset to the specified recipient. Pseudo-code for this method could look like so:</p>
<pre><code>send_asset(asset, recipient)
    self.remove_asset(asset)
    tx.create_note(recipient, asset)
end
</code></pre>
<p>In the above, <code>remove_asset</code> is a kernel procedure <code>miden::sat::account::remove_asset</code> and <code>create_note</code> is a kernel procedure <code>miden::sat::tx::create_note</code>, both in the Tx Kernel.</p>
<p><code>recipient</code> is a partial hash of the created note computed outside the VM as <code>hash(hash(hash(serial_num), script_hash), input_hash)</code>. This allows computing note hash as <code>hash(recipient, vault_hash)</code> where the <code>vault_hash</code> can be computed inside the VM based on the specified asset.</p>
<p>Note: this method also does not increment account nonce. The nonce will be incremented in auth_tx method described below. Thus, sending assets requires authentication.</p>
<h3 id="auth_tx-method"><a class="header" href="#auth_tx-method"><code>auth_tx method</code></a></h3>
<p>The purpose of this method is to authenticate a transaction. For the purposes of this method we make the following assumptions:</p>
<p>Public key of the account is stored in account storage at index 0.
To authenticate a transaction we sign <code>hash(account_id || account_nonce || input_note_hash || output_note_hash)</code> using Falcon signature scheme. Pseudo-code for this method could look like so:</p>
<pre><code>auth_tx()
    # compute the message to sign
    let account_id = self.get_id()
    let account_nonce = self.get_nonce()
    let input_notes_hash = tx.get_input_notes_hash()
    let output_notes_hash = tx.get_output_notes_hash()
    let m = hash(account_id, account_nonce, input_notes_hash, output_notes_hash)

    # get public key from account storage and verify signature
    let pub_key = self.get_item(0)
    falcon::verify_sig(pub_key, m)

    # increment account nonce
    self.increment_nonce()
end
</code></pre>
<p>It is assumed that the signature for <code>falcon::verify_sig procedure</code> will be provided non-deterministically via the advice provider. Thus, the above procedure can succeed only if the prover has a valid Falcon signature over <code>hash(account_id || account_nonce || input_note_hash || output_note_hash)</code> for the public key stored in the account.</p>
<p>All procedures invoked as a part of this method, except for <code>falcon::verify_sig</code> have equivalent kernel procedures defined in the Tx Kernel. We assume that <code>falcon::verify_sig</code> is a part of Miden standard library.</p>
<h2 id="wallet-database"><a class="header" href="#wallet-database">Wallet database</a></h2>
<p>[Unclear yet how this database looks like. It should at least have <code>assets/vault</code>, <code>code</code>, <code>nonce</code>, <code>storage</code>]</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="miden-node"><a class="header" href="#miden-node">Miden Node</a></h1>
<p>The Miden Node manages the network state and orchestrates three different modules. At the beginning we don't expect that there will be more than one Miden Node. In the futuer we aim for a decenralized network having multiple nodes managing the network state.</p>
<h2 id="transaction-prover-1"><a class="header" href="#transaction-prover-1">Transaction Prover</a></h2>
<p>The Transaction Prover can execute and prove transaction execution using the transaction kernel.</p>
<p>Note: This module also exists in the Miden Client.</p>
<h2 id="transaction-aggregator"><a class="header" href="#transaction-aggregator">Transaction Aggregator</a></h2>
<p>[Needs to be spec'd out] Goal of the Aggregator is to compress proofs by recursion and in fact prove proof verification in the Miden VM.</p>
<h2 id="block-producer"><a class="header" href="#block-producer">Block Producer</a></h2>
<p>[Needs to be spec'd out] Consists of different modules again.</p>
<ul>
<li>RPC interface</li>
<li>Tx Pool (like a mempool)</li>
<li>State databases</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="verifier-contract-1"><a class="header" href="#verifier-contract-1">Verifier Contract</a></h1>
<p>[WIP]</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="bridge"><a class="header" href="#bridge">Bridge</a></h1>
<p>[WIP]</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p>[WIP]</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p>[WIP]</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="tiered-sparse-merkle-tree-tsmt"><a class="header" href="#tiered-sparse-merkle-tree-tsmt">Tiered Sparse Merkle Tree (TSMT)</a></h1>
<p>A sparse Merkle tree (SMT) is a cryptographic data structure that allows authenticated manipulations of a key-value store, i.e. a dictionary. It is a Merkle tree because it is
a binary tree in which each leaf node represents a key-value pair, and each non-leaf node represents the hash of the concatenation of its two child nodes. The index of the
leaf node in the tree corresponds to the key and the data stored in this node corresponds to the value. This implies that the depth of such a tree is logarithmic in the size of the key space, which implies that, for most key spaces used in practice, such a tree is impractical if done naively. However, the tree is sparse, i.e. it is going to be made up of mostly empty leaves, which in turn implies that most sub-trees are empty with roots that can be pre-computed.
A major issue with SMTs is the fact that operations scale with the size of the key space, meaning, for example, that if our key space has size <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mspace nobreak"> </span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">256</span></span></span></span></span></span></span></span></span></span></span></span>, then performing any operation on the key-value store, for example, an update, will require performing <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span> hashing operations. This is undesirable both inside as well as outside the STARK.</p>
<p>A common solution to this issue is to keep only non-empty leaves in the tree, which in practice means that sub-trees with only one non-empty child are replaced with the sub-tree rooted at that non-empty child. Here's an example of this:</p>
<p align="center">
    <img src="crypto-primitives/./diagram/../../diagrams/crypto-primitives/tsmt/tsmt_compaction_example.svg">
</p>
<p>Compaction implies then that the tree depth is logarithmic in the size of the dictionary entries as opposed to the size of the key space. This, in turn, means that the number of hashing required for executing operations on the key-value map scales logarithmically in the size of the map.</p>
<p>The first documented implementation of a compact SMT was described <a href="https://github.com/proofchains/python-proofmarshal/blob/master/proofmarshal/merbinnertree.py">here</a>. This implementation relies on augmenting nodes with
a field called <code>prefix</code> which is the longest common prefix of all childs of a given node. This means that internal nodes are hashes of a left and right child together with <code>prefix</code>, i.e. <code>(LEFT || RIGHT || PREFIX)</code>. Leaf nodes are hashes of just the key-value pair. In addition, domain separation is used to distinguish
between an internal and a leaf node by appending a <code>0</code> or <code>1</code> before hashing.
A disadvantage of this implementation, as well as all known implementations of compact SMTs, is the reliance of their operations on bit-wise manipulations. This makes them very expensive to implement inside Miden VM.</p>
<p>Tiered sparse Merkle trees (TSMT) are a result of the idea that one can trade hashing for more efficient bit-wise operations. More precisely, in TSMT, compaction happens only at certain pre-specified tiers and this leads to simpler bit-wise manipulations. In the case of Miden VM, compaction happens at depths <code>16</code>, <code>32</code>, <code>48</code> and <code>64</code>. To illustrate this, consider the following example where the keys have length 4, i.e. the SMT has depth 4.</p>
<p align="center">
    <img src="crypto-primitives/./diagram/../../diagrams/crypto-primitives/tsmt/tsmt_non_compact.svg">
</p>
<p>If we choose the tiers to be at depths 2 and 4 then the compact version of the above tree will look like</p>
<p align="center">
    <img src="crypto-primitives/./diagram/../../diagrams/crypto-primitives/tsmt/tsmt_compact_2.svg">
</p>
<p>If, however, we choose compaction at all possible depths we get a compact SMT that is similar to the <a href="https://developers.diem.com/papers/jellyfish-merkle-tree/2021-01-14.pdf">Jellyfish SMT</a></p>
<p align="center">
    <img src="crypto-primitives/./diagram/../../diagrams/crypto-primitives/tsmt/tsmt_compact_1.svg">
</p>
<p>We can see that a TSMT is a parametrized SMT, where the parameter is the number of tiers, that interpolates between a plain SMT with no compaction and a  (fully) compact SMT with compaction allowed at evey depth.</p>
<p>The Miden VM TSMT is a map from a key-space of size approximately <code>256</code>-bit to a value-space of the same size and are represented by four <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span></span></span></span>-bit field elements in the Miden VM native field, i.e. a <code>Word</code>. Athough keys are <code>256</code>-bit long the maximal tree depth that is allowed is <code>64</code>. This has several consequences:</p>
<ol>
<li>Limiting the tree depth to <code>64</code> means that we can use one of the four field elements making up the (full) key as the (compact) key in the TSMT. We choose the 4th field element to act as the (compact) key since when loading the (full) key on the operand stack, the 4th field element will be at the tip of the operand stack and thus will be easier to access. Using a single field element to act as the (compact) key implies that we can levarage the native instructions of the Miden VM to manipulate it during the course of operations on the TSMT inside the VM.</li>
<li>In order to deal with keys sharing a common prefix of length greater than <code>64</code>, we introduce a special type of leaf nodes at depth <code>64</code>. These leaf nodes are a sorted list of <code>(key, value)</code> pairs where sorting is done using <code>key</code>. Notice that all pairs in the sorted list have the same first part of the key, namely they share a common <code>64</code>-bit prefix , and that all pairs with the same first part of the key belong in the same sorted list. The decision to go with a sorted list of pairs instead of a standard sub-tree node with multiple childs at depth <code>80</code> sharing the same <code>64</code>-bit prefix is partially motivated by the fact that, for most scenarios related to Miden VM, the probability that two distinct keys will end up sharing a common prefix of length greater than or equal to <code>64</code> is very low, and even feasible grinding attacks can only make the sorted list on slightly longer than a dozen of elements and with very little clear benefits. Thus putting all pairs with the same first part of the key in a sorted list is a good tradeoff for dealing with prefixes of length greater than <code>64</code>.</li>
</ol>
<p>The Miden VM TSMT has three types of nodes:</p>
<ol>
<li>Internal nodes with a left and right child, and value computed as: <code>Hash(left || right)</code></li>
<li>Leaf nodes at depths <code>16</code>, <code>32</code> and <code>48</code> with value computed as: <code>Hash(rem_key || value; domain=depth)</code> where:
<ol>
<li><code>depth</code> is the depth of the node, i.e. either <code>16</code>, <code>32</code> or <code>48</code>.</li>
<li><code>rem_key</code> is the the remaining key after either the <code>16</code>, <code>32</code> or <code>48</code>-bit prefix is removed depending on the depth of the node.</li>
<li><code>domain</code> is a domain separation tag used to distinguish between internal and leaf nodes.</li>
</ol>
</li>
<li>Leaf nodes at depth <code>64</code> with values computed as: <code>Hash((rem_key_1, value_1) || ... || (rem_key_n, value_n); domain=64)</code> where:
<ol>
<li><code>rem_key_i</code> is the remaining key after the <code>64</code>-bit prefix is removed.</li>
<li><code>value_i</code> is the value associated with the key <code>key_i</code>.</li>
<li><code>rem_key_i</code> are sorted in increasing order.</li>
</ol>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
